<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SmartEVSE-3 Traceability Report</title>
<style>

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: #f5f5f5;
    color: #333;
}
h1 { color: #1a5276; border-bottom: 3px solid #2980b9; padding-bottom: 10px; }
h2 { color: #2c3e50; margin-top: 30px; }
.summary {
    background: #fff;
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    gap: 30px;
}
.summary .stat {
    text-align: center;
}
.summary .stat .number {
    font-size: 2em;
    font-weight: bold;
    color: #2980b9;
}
.summary .stat .label {
    font-size: 0.9em;
    color: #666;
}
.feature-section {
    background: #fff;
    border-radius: 8px;
    padding: 20px;
    margin: 15px 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.feature-title {
    color: #2980b9;
    font-size: 1.3em;
    margin: 0 0 15px 0;
    padding-bottom: 8px;
    border-bottom: 2px solid #eee;
}
table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9em;
}
th {
    background: #2c3e50;
    color: white;
    padding: 10px 12px;
    text-align: left;
}
td {
    padding: 8px 12px;
    border-bottom: 1px solid #eee;
    vertical-align: top;
}
tr:hover { background: #f8f9fa; }
.req-tag {
    background: #e8f4fd;
    color: #1a5276;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.85em;
    font-weight: 500;
    white-space: nowrap;
}
.no-req {
    color: #999;
    font-style: italic;
    font-size: 0.85em;
}
.scenario-steps {
    margin: 4px 0 0 0;
    padding: 0;
    list-style: none;
    font-size: 0.85em;
    color: #555;
}
.scenario-steps li { margin: 2px 0; }
.step-given { color: #27ae60; }
.step-when { color: #2980b9; }
.step-then { color: #8e44ad; }
.step-keyword { font-weight: bold; }
.file-ref {
    font-family: monospace;
    font-size: 0.85em;
    color: #666;
}
.coverage-bar {
    height: 8px;
    background: #ecf0f1;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 5px;
}
.coverage-fill {
    height: 100%;
    background: #27ae60;
    border-radius: 4px;
}
footer {
    text-align: center;
    margin-top: 30px;
    padding: 15px;
    color: #999;
    font-size: 0.85em;
}

</style>
</head>
<body>
<h1>SmartEVSE-3 Traceability Report</h1>
<div class="summary">
<div class="stat"><div class="number">38</div><div class="label">Features</div></div>
<div class="stat"><div class="number">525</div><div class="label">Test Scenarios</div></div>
<div class="stat"><div class="number">525</div><div class="label">With Requirements</div></div>
<div class="stat"><div class="number">100%</div><div class="label">Requirement Coverage</div></div>
</div>
<div class="feature-section">
<div class="feature-title">Authorization &amp; Access Control (17 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-AUTH-001</span></td>
<td>Setting access to ON stores the authorization status</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised in basic configuration</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with ON</li><li class="step-then"><span class="step-keyword">Then</span> AccessStatus is set to ON</li></ul></td>
<td><code>test_set_access_on</code></td>
<td><span class="file-ref">test_authorization.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-002</span></td>
<td>Setting access to OFF stores the authorization status</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised in basic configuration</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with OFF</li><li class="step-then"><span class="step-keyword">Then</span> AccessStatus is set to OFF</li></ul></td>
<td><code>test_set_access_off</code></td>
<td><span class="file-ref">test_authorization.c:40</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-003</span></td>
<td>Revoking access during charging suspends the session (C -&gt; C1)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging) with AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with OFF</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_C1 and AccessStatus is OFF</li></ul></td>
<td><code>test_set_access_off_from_C_goes_C1</code></td>
<td><span class="file-ref">test_authorization.c:54</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-004</span></td>
<td>Pausing access during charging suspends the session (C -&gt; C1)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging) with AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with PAUSE</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_C1 and AccessStatus is PAUSE</li></ul></td>
<td><code>test_set_access_pause_from_C_goes_C1</code></td>
<td><span class="file-ref">test_authorization.c:73</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-005</span></td>
<td>Revoking access in STATE_B moves to waiting state (B -&gt; B1)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B (connected) with AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with OFF</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (waiting)</li></ul></td>
<td><code>test_set_access_off_from_B_goes_B1</code></td>
<td><span class="file-ref">test_authorization.c:91</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-006</span></td>
<td>Revoking access during modem request aborts to B1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_REQUEST with AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with OFF</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (waiting)</li></ul></td>
<td><code>test_set_access_off_from_modem_request_goes_B1</code></td>
<td><span class="file-ref">test_authorization.c:108</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-007</span></td>
<td>Revoking access during modem wait aborts to B1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_WAIT with AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with OFF</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (waiting)</li></ul></td>
<td><code>test_set_access_off_from_modem_wait_goes_B1</code></td>
<td><span class="file-ref">test_authorization.c:125</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-008</span></td>
<td>Revoking access in STATE_A has no state transition side effect</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A (disconnected)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with OFF</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_A</li></ul></td>
<td><code>test_set_access_off_from_A_stays_A</code></td>
<td><span class="file-ref">test_authorization.c:142</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-009</span></td>
<td>Granting access in STATE_B1 does not auto-recover to STATE_B</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B1 (waiting)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_access is called with ON</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_B1 (no automatic recovery)</li></ul></td>
<td><code>test_set_access_on_from_B1_does_not_auto_recover</code></td>
<td><span class="file-ref">test_authorization.c:157</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-010</span></td>
<td>OCPP current limit below MinCurrent blocks current availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> OCPP mode is enabled with OcppCurrentLimit=3A and MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> The function returns 0 (current not available)</li></ul></td>
<td><code>test_ocpp_blocks_current_availability</code></td>
<td><span class="file-ref">test_authorization.c:175</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-011</span></td>
<td>OCPP current limit above MinCurrent allows current availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> OCPP mode is enabled with OcppCurrentLimit=10A and MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> The function returns 1 (current available)</li></ul></td>
<td><code>test_ocpp_allows_when_limit_sufficient</code></td>
<td><span class="file-ref">test_authorization.c:192</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-012</span></td>
<td>Negative OCPP current limit is ignored (not set)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> OCPP mode is enabled with OcppCurrentLimit=-1 (unset)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> The function returns 1 (limit not applied)</li></ul></td>
<td><code>test_ocpp_negative_limit_ignored</code></td>
<td><span class="file-ref">test_authorization.c:210</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-014</span></td>
<td>Access timer counts down each second while in STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has AccessStatus ON, RFIDReader=2, and AccessTimer=0</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with AccessTimer=5</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (EV disconnects)</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> AccessTimer is set to RFIDLOCKTIME</li><li class="step-then"><span class="step-keyword">Then</span> AccessTimer decrements to 4</li></ul></td>
<td><code>test_access_timer_counts_down_in_state_A</code></td>
<td><span class="file-ref">test_authorization.c:229</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-015</span></td>
<td>Access timer expiry revokes authorization</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with AccessTimer=1 and AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs (timer reaches 0)</li><li class="step-then"><span class="step-keyword">Then</span> AccessStatus is set to OFF (authorization revoked)</li></ul></td>
<td><code>test_access_timer_expires_turns_off</code></td>
<td><span class="file-ref">test_authorization.c:266</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-016</span></td>
<td>Access timer is cleared when EVSE is not in STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with AccessTimer=30</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> AccessTimer is reset to 0</li></ul></td>
<td><code>test_access_timer_cleared_when_not_in_A</code></td>
<td><span class="file-ref">test_authorization.c:284</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-017</span></td>
<td>No STATE_A to STATE_B transition without authorization</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with AccessStatus OFF</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_A (transition blocked)</li></ul></td>
<td><code>test_no_A_to_B_without_access</code></td>
<td><span class="file-ref">test_authorization.c:303</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-AUTH-018</span></td>
<td>No STATE_B to STATE_C transition after access revoked mid-session</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with DiodeCheck passed but AccessStatus revoked to OFF</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal is sustained for 500ms</li><li class="step-then"><span class="step-keyword">Then</span> The state does NOT transition to STATE_C</li></ul></td>
<td><code>test_no_B_to_C_without_access</code></td>
<td><span class="file-ref">test_authorization.c:318</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Dual-EVSE Load Balancing (23 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-DUAL-S1A</span></td>
<td>Both EVSEs get equal share of MaxCircuit in Normal mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs both in STATE_C, Normal mode, MaxCircuit=32A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=1) is called</li><li class="step-then"><span class="step-keyword">Then</span> Each EVSE gets 160 (16A), equal split of 320 IsetBalanced</li></ul></td>
<td><code>test_s1_both_start_equal_split</code></td>
<td><span class="file-ref">test_dual_evse.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S1B</span></td>
<td>IsetBalanced equals MaxCircuit * 10 in Normal mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs in Normal mode</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=1)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced = MaxCircuit * 10 = 320</li></ul></td>
<td><code>test_s1_isetbalanced_equals_max_circuit</code></td>
<td><span class="file-ref">test_dual_evse.c:67</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S1C</span></td>
<td>EV meter baseload reduces available current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs, EV meter reads 200 (other loads on circuit)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=1)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced reduced by baseload</li></ul></td>
<td><code>test_s1_ev_meter_baseload</code></td>
<td><span class="file-ref">test_dual_evse.c:85</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S2A</span></td>
<td>Master reduces current when slave joins</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master alone at 160, slave not active</li><li class="step-when"><span class="step-keyword">When</span> Slave enters STATE_C and calc runs with mod=1</li><li class="step-then"><span class="step-keyword">Then</span> Both get equal share (160 each with MaxCircuit=32)</li></ul></td>
<td><code>test_s2_slave_joins_master_reduces</code></td>
<td><span class="file-ref">test_dual_evse.c:112</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S2B</span></td>
<td>Slave node sends COMM_B on car connect</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Slave EVSE (LoadBl=2) in STATE_A with 9V pilot</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_9V</li><li class="step-then"><span class="step-keyword">Then</span> Transitions to STATE_COMM_B (requests master permission)</li></ul></td>
<td><code>test_s2_slave_sends_comm_b</code></td>
<td><span class="file-ref">test_dual_evse.c:145</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S3A</span></td>
<td>MaxCircuit reduction redistributes current equally</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Both at 160 with MaxCircuit=32</li><li class="step-when"><span class="step-keyword">When</span> MaxCircuit reduced to 20</li><li class="step-then"><span class="step-keyword">Then</span> Each gets 100 (200 / 2)</li></ul></td>
<td><code>test_s3_maxcircuit_reduction</code></td>
<td><span class="file-ref">test_dual_evse.c:170</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S3B</span></td>
<td>MaxCircuit at exactly 2 * MinCurrent gives each MinCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Both in STATE_C, MaxCircuit=12</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current</li><li class="step-then"><span class="step-keyword">Then</span> Each gets exactly 60 (MinCurrent * 10)</li></ul></td>
<td><code>test_s3_maxcircuit_to_mincurrent</code></td>
<td><span class="file-ref">test_dual_evse.c:191</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S4A</span></td>
<td>Slave disconnects, master gets capped at BalancedMax</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Both at 160, slave disconnects (STATE_A)</li><li class="step-when"><span class="step-keyword">When</span> Recalculation runs</li><li class="step-then"><span class="step-keyword">Then</span> Master gets BalancedMax[0]=160, slave gets 0</li></ul></td>
<td><code>test_s4_slave_disconnects</code></td>
<td><span class="file-ref">test_dual_evse.c:215</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S4B</span></td>
<td>Master with higher MaxCurrent gets more after slave disconnect</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master MaxCurrent=32, MaxCircuit=40, slave disconnects</li><li class="step-when"><span class="step-keyword">When</span> Recalculation with mod=0</li><li class="step-then"><span class="step-keyword">Then</span> Master gets up to 320 (BalancedMax[0]=ChargeCurrent=320)</li></ul></td>
<td><code>test_s4_master_absorbs_full_capacity</code></td>
<td><span class="file-ref">test_dual_evse.c:240</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S5A</span></td>
<td>Smart mode: new EVSE joining recalculates from mains headroom</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master in MODE_SMART, both in STATE_C, MaxMains=32A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=1)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced based on (MaxMains*10) - Baseload</li></ul></td>
<td><code>test_s5_smart_mode_new_join</code></td>
<td><span class="file-ref">test_dual_evse.c:273</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S5B</span></td>
<td>Smart mode: surplus increases IsetBalanced gradually</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODE_SMART, low mains load, IsetBalanced=200</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=0)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced increases by Idifference/4</li></ul></td>
<td><code>test_s5_smart_surplus_increases</code></td>
<td><span class="file-ref">test_dual_evse.c:297</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S5C</span></td>
<td>Smart mode: overload decreases IsetBalanced immediately</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODE_SMART, high mains load</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=0)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced decreases by full Idifference</li></ul></td>
<td><code>test_s5_smart_overload_decreases</code></td>
<td><span class="file-ref">test_dual_evse.c:321</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S6A</span></td>
<td>Solar mode: both EVSEs in startup get MinCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODE_SOLAR, both in STATE_C with IntTimer &lt; SOLARSTARTTIME</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current</li><li class="step-then"><span class="step-keyword">Then</span> Both receive exactly MinCurrent * 10 = 60</li></ul></td>
<td><code>test_s6_solar_both_in_startup</code></td>
<td><span class="file-ref">test_dual_evse.c:348</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S6B</span></td>
<td>Solar mode: insufficient solar starts SolarStopTimer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODE_SOLAR, high grid import, past startup</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current</li><li class="step-then"><span class="step-keyword">Then</span> SolarStopTimer is set</li></ul></td>
<td><code>test_s6_solar_insufficient_starts_timer</code></td>
<td><span class="file-ref">test_dual_evse.c:376</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S7A</span></td>
<td>Zero available power pauses all EVSEs via priority scheduling</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Smart mode, MaxMains=5A, heavy mains load (IsetBalanced drops to 0)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current</li><li class="step-then"><span class="step-keyword">Then</span> Both EVSEs paused (Balanced=0), NoCurrent increments (true hard shortage)</li></ul></td>
<td><code>test_s7_mincurrent_violation</code></td>
<td><span class="file-ref">test_dual_evse.c:412</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S7B</span></td>
<td>Exactly 2 * MinCurrent — no shortage</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Normal mode, MaxCircuit=12</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current</li><li class="step-then"><span class="step-keyword">Then</span> Each gets 60, NoCurrent stays 0</li></ul></td>
<td><code>test_s7_barely_enough</code></td>
<td><span class="file-ref">test_dual_evse.c:440</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S8A</span></td>
<td>Slave error → master absorbs capacity</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Both at 160 each, slave enters B1</li><li class="step-when"><span class="step-keyword">When</span> Recalculation</li><li class="step-then"><span class="step-keyword">Then</span> Master gets 160 (capped by BalancedMax)</li></ul></td>
<td><code>test_s8_slave_error_master_absorbs</code></td>
<td><span class="file-ref">test_dual_evse.c:465</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S8B</span></td>
<td>Slave recovers, current redistributed</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master alone at 160, slave re-enters STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=1)</li><li class="step-then"><span class="step-keyword">Then</span> Both get equal share</li></ul></td>
<td><code>test_s8_slave_recovers</code></td>
<td><span class="file-ref">test_dual_evse.c:488</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S9A</span></td>
<td>MaxSumMains overridden Idifference limits IsetBalanced</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODE_SMART, MaxSumMains=30, Isum close to limit</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(mod=0)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced constrained by MaxSumMains</li></ul></td>
<td><code>test_s9_maxsummains_limits</code></td>
<td><span class="file-ref">test_dual_evse.c:520</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S9B</span></td>
<td>MaxSumMains timer expiry stops charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> STATE_C with MaxSumMainsTimer=1</li><li class="step-when"><span class="step-keyword">When</span> evse_tick_1s (timer expires)</li><li class="step-then"><span class="step-keyword">Then</span> C → C1, LESS_6A set</li></ul></td>
<td><code>test_s9_maxsummains_timer_expiry</code></td>
<td><span class="file-ref">test_dual_evse.c:546</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S10A</span></td>
<td>Normal mode forces 3P when currently on 1P</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Normal mode, Nr_Of_Phases_Charging=1</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 = GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_s10_normal_forces_3p</code></td>
<td><span class="file-ref">test_dual_evse.c:578</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S10B</span></td>
<td>STATE_C entry applies 1P switch</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Switching_Phases_C2=GOING_TO_SWITCH_1P, EnableC2=ALWAYS_OFF</li><li class="step-when"><span class="step-keyword">When</span> evse_set_state(STATE_C)</li><li class="step-then"><span class="step-keyword">Then</span> Nr_Of_Phases_Charging=1, contactor2 off</li></ul></td>
<td><code>test_s10_state_c_applies_1p</code></td>
<td><span class="file-ref">test_dual_evse.c:597</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-DUAL-S10C</span></td>
<td>Smart mode with AUTO forces back to 3P</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODE_SMART, EnableC2=AUTO, Nr_Of_Phases_Charging=1</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 = GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_s10_smart_auto_forces_3p</code></td>
<td><span class="file-ref">test_dual_evse.c:617</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">End-to-End Charging (12 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-E2E-001</span></td>
<td>Complete standalone charge cycle with DiodeCheck</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Standalone EVSE, authorized, Normal mode</li><li class="step-when"><span class="step-keyword">When</span> Car connects (9V) → DiodeCheck (DIODE) → requests charge (6V) → stops (9V) → disconnects (12V)</li><li class="step-then"><span class="step-keyword">Then</span> Full cycle: A → B → (DiodeCheck) → C → B → A with correct contactor states</li></ul></td>
<td><code>test_e2e_standalone_happy_path</code></td>
<td><span class="file-ref">test_e2e_charging.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-002</span></td>
<td>Slave EVSE full charge cycle with master handshake</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Slave EVSE (LoadBl=2), authorized</li><li class="step-when"><span class="step-keyword">When</span> Car connects → COMM_B → master approves → B → DiodeCheck → 6V → COMM_C → master approves → C → disconnect</li><li class="step-then"><span class="step-keyword">Then</span> Full slave cycle: A → COMM_B → COMM_B_OK → B → COMM_C → COMM_C_OK → C → B → A</li></ul></td>
<td><code>test_e2e_slave_happy_path</code></td>
<td><span class="file-ref">test_e2e_charging.c:99</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-003</span></td>
<td>OCPP grants access mid-session, car starts charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Standalone EVSE with OcppMode=true, AccessStatus=OFF</li><li class="step-when"><span class="step-keyword">When</span> Car connects, OCPP grants access, car charges, OCPP revokes</li><li class="step-then"><span class="step-keyword">Then</span> A (blocked) → A (OCPP grants) → B → C → C1 (revoked) → B1</li></ul></td>
<td><code>test_e2e_ocpp_authorization_flow</code></td>
<td><span class="file-ref">test_e2e_charging.c:152</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-004</span></td>
<td>OCPP denied — car connects but stays in STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> OCPP mode with AccessStatus=OFF</li><li class="step-when"><span class="step-keyword">When</span> Car repeatedly presents 9V pilot</li><li class="step-then"><span class="step-keyword">Then</span> State stays A for 100+ ticks</li></ul></td>
<td><code>test_e2e_ocpp_denied_stays_in_a</code></td>
<td><span class="file-ref">test_e2e_charging.c:200</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-005</span></td>
<td>Two full charge cycles — verify no stale state leaks</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Standalone EVSE</li><li class="step-when"><span class="step-keyword">When</span> First cycle: connect → charge → disconnect. Second cycle: connect → charge → disconnect.</li><li class="step-then"><span class="step-keyword">Then</span> Both cycles complete successfully, all state is clean between them</li></ul></td>
<td><code>test_e2e_reconnect_after_disconnect</code></td>
<td><span class="file-ref">test_e2e_charging.c:224</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-006</span></td>
<td>Temperature spike during STATE_C, recovery after cooldown</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE charging in STATE_C</li><li class="step-when"><span class="step-keyword">When</span> Temperature exceeds maxTemp, then cools below hysteresis</li><li class="step-then"><span class="step-keyword">Then</span> C → C1 → B1 (TEMP_HIGH), cooldown clears error</li></ul></td>
<td><code>test_e2e_temp_error_during_charge</code></td>
<td><span class="file-ref">test_e2e_charging.c:279</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-007</span></td>
<td>Meter communication lost during STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE charging in Smart mode with MainsMeter</li><li class="step-when"><span class="step-keyword">When</span> Meter timeout reaches 0</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM set, power unavailable, C → C1</li></ul></td>
<td><code>test_e2e_ct_nocomm_during_charge</code></td>
<td><span class="file-ref">test_e2e_charging.c:318</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-008</span></td>
<td>TEMP_HIGH + CT_NOCOMM simultaneously during charge</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE charging in Smart mode</li><li class="step-when"><span class="step-keyword">When</span> Temperature spikes AND meter fails at same time</li><li class="step-then"><span class="step-keyword">Then</span> Both errors set, both must clear for full recovery</li></ul></td>
<td><code>test_e2e_multiple_errors_during_charge</code></td>
<td><span class="file-ref">test_e2e_charging.c:355</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-009</span></td>
<td>6V pilot without DiodeCheck does not transition to STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE in STATE_B, DiodeCheck=0</li><li class="step-when"><span class="step-keyword">When</span> 55 ticks of 6V pilot</li><li class="step-then"><span class="step-keyword">Then</span> State stays STATE_B (DiodeCheck blocks B→C)</li></ul></td>
<td><code>test_e2e_no_charge_without_diode</code></td>
<td><span class="file-ref">test_e2e_charging.c:393</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-010</span></td>
<td>ChargeDelay &gt; 0 blocks A→B transition, sends to B1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Standalone EVSE with ChargeDelay=10</li><li class="step-when"><span class="step-keyword">When</span> Car connects (9V)</li><li class="step-then"><span class="step-keyword">Then</span> Goes to B1 (not B), must wait for delay to expire</li></ul></td>
<td><code>test_e2e_charge_delay_blocks_charging</code></td>
<td><span class="file-ref">test_e2e_charging.c:420</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-011</span></td>
<td>StateTimer is properly reset between charge sessions</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE in STATE_C with accumulated StateTimer</li><li class="step-when"><span class="step-keyword">When</span> Car stops (9V → B), then requests charge again (6V)</li><li class="step-then"><span class="step-keyword">Then</span> Debounce starts from 0, requiring full 500ms</li></ul></td>
<td><code>test_e2e_state_timer_reset_on_c_to_b</code></td>
<td><span class="file-ref">test_e2e_charging.c:446</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-E2E-012</span></td>
<td>Power unavailable during charge suspends charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE charging in STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_set_power_unavailable is called</li><li class="step-then"><span class="step-keyword">Then</span> C → C1 (PWM off) → B1 (contactors open after C1Timer)</li></ul></td>
<td><code>test_e2e_power_unavailable_c_to_c1_to_b1</code></td>
<td><span class="file-ref">test_e2e_charging.c:488</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Error Handling &amp; Safety (29 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-ERR-001</span></td>
<td>Setting an error flag stores it in ErrorFlags</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with no errors</li><li class="step-when"><span class="step-keyword">When</span> evse_set_error_flags is called with TEMP_HIGH</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH bit is set in ErrorFlags</li></ul></td>
<td><code>test_set_error_flags</code></td>
<td><span class="file-ref">test_error_handling.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-002</span></td>
<td>Multiple error flags can be set simultaneously</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with no errors</li><li class="step-when"><span class="step-keyword">When</span> evse_set_error_flags is called with TEMP_HIGH then CT_NOCOMM</li><li class="step-then"><span class="step-keyword">Then</span> Both TEMP_HIGH and CT_NOCOMM bits are set in ErrorFlags</li></ul></td>
<td><code>test_set_multiple_error_flags</code></td>
<td><span class="file-ref">test_error_handling.c:46</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-003</span></td>
<td>Clearing an error flag removes only the specified flag</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has TEMP_HIGH and CT_NOCOMM error flags set</li><li class="step-when"><span class="step-keyword">When</span> evse_clear_error_flags is called with TEMP_HIGH</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH is cleared but CT_NOCOMM remains set</li></ul></td>
<td><code>test_clear_error_flags</code></td>
<td><span class="file-ref">test_error_handling.c:62</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-004</span></td>
<td>Clearing one flag preserves all other active flags</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has TEMP_HIGH, LESS_6A, and CT_NOCOMM error flags set</li><li class="step-when"><span class="step-keyword">When</span> evse_clear_error_flags is called with LESS_6A</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH and CT_NOCOMM remain set, LESS_6A is cleared</li></ul></td>
<td><code>test_clear_preserves_other_flags</code></td>
<td><span class="file-ref">test_error_handling.c:78</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-005</span></td>
<td>ChargeDelay decrements each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has ChargeDelay set to 10</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay decrements to 9</li></ul></td>
<td><code>test_charge_delay_counts_down</code></td>
<td><span class="file-ref">test_error_handling.c:97</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-006</span></td>
<td>ChargeDelay does not underflow past zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has ChargeDelay set to 1</li><li class="step-when"><span class="step-keyword">When</span> Two second ticks occur</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay reaches 0 and stays at 0</li></ul></td>
<td><code>test_charge_delay_stops_at_zero</code></td>
<td><span class="file-ref">test_error_handling.c:112</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-008</span></td>
<td>Temperature exceeding maxTemp triggers TEMP_HIGH error</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with ChargeDelay=5 and AccessStatus ON</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is charging with TempEVSE=70 and maxTemp=65</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 instead of STATE_B</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH error flag is set in ErrorFlags</li></ul></td>
<td><code>test_temp_high_triggers_error</code></td>
<td><span class="file-ref">test_error_handling.c:129</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-009</span></td>
<td>Overtemperature shuts down active charging session</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging) with TempEVSE=70 and maxTemp=65</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs triggering temperature protection</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions out of STATE_C (charging suspended)</li></ul></td>
<td><code>test_temp_high_shuts_down_charging</code></td>
<td><span class="file-ref">test_error_handling.c:165</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-010</span></td>
<td>Temperature recovery requires 10-degree hysteresis below maxTemp</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has TEMP_HIGH error with maxTemp=65</li><li class="step-when"><span class="step-keyword">When</span> Temperature drops to 60 (within hysteresis) then to 50 (below threshold)</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH persists at 60 but clears at 50 (below maxTemp-10)</li></ul></td>
<td><code>test_temp_recovery_with_hysteresis</code></td>
<td><span class="file-ref">test_error_handling.c:182</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-011</span></td>
<td>Temperature recovery boundary: exactly at threshold does not clear</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has TEMP_HIGH error with maxTemp=65</li><li class="step-when"><span class="step-keyword">When</span> Temperature is exactly 55 (maxTemp-10) then drops to 54</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH persists at 55 but clears at 54 (strictly below threshold)</li></ul></td>
<td><code>test_temp_recovery_boundary</code></td>
<td><span class="file-ref">test_error_handling.c:206</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-012</span></td>
<td>Mains meter communication timeout sets CT_NOCOMM error</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with MainsMeterTimeout=0 (timed out)</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM error flag is set</li></ul></td>
<td><code>test_mains_meter_timeout_sets_ct_nocomm</code></td>
<td><span class="file-ref">test_error_handling.c:232</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-013</span></td>
<td>Mains meter timeout counter decrements each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with MainsMeterTimeout=5</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> MainsMeterTimeout decrements to 4</li></ul></td>
<td><code>test_mains_meter_timeout_counts_down</code></td>
<td><span class="file-ref">test_error_handling.c:250</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-014</span></td>
<td>Normal mode ignores mains meter timeout (no CT_NOCOMM)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_NORMAL with MainsMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM error flag is NOT set</li></ul></td>
<td><code>test_mains_meter_normal_mode_ignores_timeout</code></td>
<td><span class="file-ref">test_error_handling.c:268</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-015</span></td>
<td>No mains meter configured resets timeout to COMM_TIMEOUT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has MainsMeterType=0 (no meter) with MainsMeterTimeout=3</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> MainsMeterTimeout is reset to COMM_TIMEOUT</li></ul></td>
<td><code>test_no_mains_meter_resets_timeout</code></td>
<td><span class="file-ref">test_error_handling.c:287</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-016</span></td>
<td>EV meter communication timeout sets EV_NOCOMM error</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has EVMeterType=1 with EVMeterTimeout=0 (timed out)</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EV_NOCOMM error flag is set</li></ul></td>
<td><code>test_ev_meter_timeout_sets_ev_nocomm</code></td>
<td><span class="file-ref">test_error_handling.c:306</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-017</span></td>
<td>No EV meter configured resets timeout to COMM_EVTIMEOUT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has EVMeterType=0 (no meter) with EVMeterTimeout=3</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EVMeterTimeout is reset to COMM_EVTIMEOUT</li></ul></td>
<td><code>test_no_ev_meter_resets_timeout</code></td>
<td><span class="file-ref">test_error_handling.c:323</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-018</span></td>
<td>CT_NOCOMM error clears when mains meter communication resumes</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has CT_NOCOMM error with MainsMeterTimeout=5 (restored)</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM error flag is cleared</li></ul></td>
<td><code>test_ct_nocomm_recovers_on_communication</code></td>
<td><span class="file-ref">test_error_handling.c:341</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-019</span></td>
<td>EV_NOCOMM error clears when EV meter communication resumes</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has EV_NOCOMM error with EVMeterTimeout=5 (restored)</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EV_NOCOMM error flag is cleared</li></ul></td>
<td><code>test_ev_nocomm_recovers_on_communication</code></td>
<td><span class="file-ref">test_error_handling.c:357</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-020</span></td>
<td>LESS_6A error auto-recovers when sufficient current becomes available</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_NORMAL standalone with LESS_6A error and AccessStatus ON</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs (normal mode always has current available)</li><li class="step-then"><span class="step-keyword">Then</span> LESS_6A error flag is cleared</li></ul></td>
<td><code>test_less_6a_recovers_when_current_available</code></td>
<td><span class="file-ref">test_error_handling.c:375</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-021</span></td>
<td>LESS_6A error persists when current is still unavailable</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with LESS_6A error and mains heavily loaded</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> LESS_6A error flag remains set</li></ul></td>
<td><code>test_less_6a_stays_when_current_unavailable</code></td>
<td><span class="file-ref">test_error_handling.c:394</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-022</span></td>
<td>Node EVSEs (LoadBl &gt;= 2) do not auto-recover LESS_6A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is configured as a node (LoadBl=3) with LESS_6A error</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> LESS_6A error flag remains set (nodes rely on master for recovery)</li></ul></td>
<td><code>test_less_6a_no_recovery_for_nodes</code></td>
<td><span class="file-ref">test_error_handling.c:414</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-023</span></td>
<td>Power unavailable during charging suspends to STATE_C1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_power_unavailable is called</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_C1 (charging suspended)</li></ul></td>
<td><code>test_power_unavailable_from_C_goes_C1</code></td>
<td><span class="file-ref">test_error_handling.c:434</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-024</span></td>
<td>Power unavailable in STATE_B moves to waiting state B1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B (connected)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_power_unavailable is called</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (waiting)</li></ul></td>
<td><code>test_power_unavailable_from_B_goes_B1</code></td>
<td><span class="file-ref">test_error_handling.c:448</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-025</span></td>
<td>Power unavailable in STATE_A has no effect</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A (disconnected)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_power_unavailable is called</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_A</li></ul></td>
<td><code>test_power_unavailable_from_A_stays_A</code></td>
<td><span class="file-ref">test_error_handling.c:464</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-026</span></td>
<td>Power unavailable in STATE_B1 remains in B1 (already waiting)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B1 (waiting)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_power_unavailable is called</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_B1</li></ul></td>
<td><code>test_power_unavailable_from_B1_stays_B1</code></td>
<td><span class="file-ref">test_error_handling.c:479</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-027</span></td>
<td>Power unavailable in STATE_C1 remains in C1 (already suspended)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C1 (charging suspended)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_power_unavailable is called</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_C1</li></ul></td>
<td><code>test_power_unavailable_from_C1_stays_C1</code></td>
<td><span class="file-ref">test_error_handling.c:494</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-028</span></td>
<td>Entering STATE_B1 disconnects pilot when authorized</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has AccessStatus ON and PilotDisconnected is false</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_B1</li><li class="step-then"><span class="step-keyword">Then</span> PilotDisconnected is true and pilot_connected is false</li></ul></td>
<td><code>test_pilot_disconnect_on_B1_entry</code></td>
<td><span class="file-ref">test_error_handling.c:511</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-029</span></td>
<td>Pilot reconnects after PilotDisconnectTime expires</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has PilotDisconnectTime=2 with pilot disconnected</li><li class="step-when"><span class="step-keyword">When</span> Two second ticks occur</li><li class="step-then"><span class="step-keyword">Then</span> PilotDisconnected is cleared and pilot_connected is restored</li></ul></td>
<td><code>test_pilot_reconnect_after_timer</code></td>
<td><span class="file-ref">test_error_handling.c:528</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-ERR-030</span></td>
<td>MaxSumMains timer expiry stops charging with LESS_6A error</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is charging with MaxSumMainsTimer=1 and mains heavily loaded</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs (timer expires)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_C1 and LESS_6A error flag is set</li></ul></td>
<td><code>test_maxsummains_timer_stops_charging</code></td>
<td><span class="file-ref">test_error_handling.c:560</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: DisconnectTimeCounter (3 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-D1A</span></td>
<td>Module tick_1s does not increment DisconnectTimeCounter</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=true, DisconnectTimeCounter=0</li><li class="step-when"><span class="step-keyword">When</span> tick_1s is called</li><li class="step-then"><span class="step-keyword">Then</span> Counter stays 0 (firmware wrapper handles increment + pilot check)</li></ul></td>
<td><code>test_fid_disconnect_counter_not_in_module</code></td>
<td><span class="file-ref">test_fidelity.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D1B</span></td>
<td>Module correctly sets counter via set_state for STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=true, DisconnectTimeCounter=-1</li><li class="step-when"><span class="step-keyword">When</span> evse_set_state to STATE_A</li><li class="step-then"><span class="step-keyword">Then</span> Counter is set to 0 (start counting)</li></ul></td>
<td><code>test_fid_disconnect_counter_starts_on_state_a</code></td>
<td><span class="file-ref">test_fidelity.c:59</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D1C</span></td>
<td>Module disables counter on MODEM_REQUEST entry</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> DisconnectTimeCounter=5</li><li class="step-when"><span class="step-keyword">When</span> evse_set_state to STATE_MODEM_REQUEST</li><li class="step-then"><span class="step-keyword">Then</span> Counter is set to -1 (disabled)</li></ul></td>
<td><code>test_fid_disconnect_counter_disabled_on_modem_request</code></td>
<td><span class="file-ref">test_fidelity.c:75</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: PilotDisconnectTime (2 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-D2A</span></td>
<td>tick_1s only decrements timer, does not reconnect</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> PilotDisconnectTime=1, PilotDisconnected=true</li><li class="step-when"><span class="step-keyword">When</span> tick_1s is called (timer reaches 0)</li><li class="step-then"><span class="step-keyword">Then</span> PilotDisconnected is still true (reconnect happens in tick_10ms)</li></ul></td>
<td><code>test_fid_pilot_disconnect_no_reconnect_in_tick_1s</code></td>
<td><span class="file-ref">test_fidelity.c:95</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D2B</span></td>
<td>tick_10ms reconnects when PilotDisconnectTime reaches 0</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> PilotDisconnected=true, PilotDisconnectTime=0, State=B1</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms is called with PILOT_9V</li><li class="step-then"><span class="step-keyword">Then</span> PilotDisconnected=false, pilot_connected=true</li></ul></td>
<td><code>test_fid_pilot_disconnect_reconnects_in_tick_10ms</code></td>
<td><span class="file-ref">test_fidelity.c:116</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: Fall-through behavior (5 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-D3A</span></td>
<td>COMM_B_OK transitions to STATE_B and B handler runs same tick</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=COMM_B_OK, DiodeCheck=0</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_DIODE</li><li class="step-then"><span class="step-keyword">Then</span> State=STATE_B, and DiodeCheck=1 (B handler fired in same tick)</li></ul></td>
<td><code>test_fid_comm_b_ok_falls_through_to_b_handler</code></td>
<td><span class="file-ref">test_fidelity.c:141</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D3B</span></td>
<td>COMM_B_OK → B → 12V disconnect in same tick</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=COMM_B_OK</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_12V</li><li class="step-then"><span class="step-keyword">Then</span> State=STATE_A (B handler detects disconnect in same tick)</li></ul></td>
<td><code>test_fid_comm_b_ok_to_b_then_disconnect</code></td>
<td><span class="file-ref">test_fidelity.c:161</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D4A</span></td>
<td>A→B transition allows B handler to run and detect PILOT_DIODE</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=STATE_A, PILOT_DIODE would trigger A→B on 9V but we pass 9V</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_9V in STATE_A with access</li><li class="step-then"><span class="step-keyword">Then</span> State=STATE_B, ActivationMode=30, and StateTimer reset to 0</li></ul></td>
<td><code>test_fid_a_to_b_falls_through_to_b_handler</code></td>
<td><span class="file-ref">test_fidelity.c:183</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D5A</span></td>
<td>COMM_C_OK transitions to STATE_C and C handler runs same tick</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=COMM_C_OK</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_6V</li><li class="step-then"><span class="step-keyword">Then</span> State=STATE_C, StateTimer=0 (C handler&#x27;s else resets StateTimer)</li></ul></td>
<td><code>test_fid_comm_c_ok_falls_through_to_c_handler</code></td>
<td><span class="file-ref">test_fidelity.c:208</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D5B</span></td>
<td>COMM_C_OK → C → immediate 12V disconnect in same tick</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=COMM_C_OK</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_12V</li><li class="step-then"><span class="step-keyword">Then</span> State=STATE_A (C handler detects disconnect immediately)</li></ul></td>
<td><code>test_fid_comm_c_ok_to_c_then_disconnect</code></td>
<td><span class="file-ref">test_fidelity.c:230</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: ACTSTART no pilot check (2 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-D6A</span></td>
<td>ACTSTART ignores PILOT_12V (original has no pilot check here)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=ACTSTART with timer running (3 seconds)</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_12V</li><li class="step-then"><span class="step-keyword">Then</span> State stays ACTSTART (timer must expire → B → detects 12V → A)</li></ul></td>
<td><code>test_fid_actstart_no_pilot_12v_check</code></td>
<td><span class="file-ref">test_fidelity.c:252</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-D6B</span></td>
<td>ACTSTART timer expiry leads to STATE_B (B handler is before ACTSTART</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=ACTSTART, ActivationTimer=0</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_12V, then another tick_10ms with PILOT_12V</li><li class="step-then"><span class="step-keyword">Then</span> First tick: ACTSTART → B. Second tick: B → A (12V detected)</li></ul></td>
<td><code>test_fid_actstart_timer_then_disconnect</code></td>
<td><span class="file-ref">test_fidelity.c:270</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: Modem states not in tick_10ms (1 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-D7A</span></td>
<td>Modem states are invisible to tick_10ms</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE in each modem state</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with any pilot value</li><li class="step-then"><span class="step-keyword">Then</span> State does not change (modem managed entirely by tick_1s)</li></ul></td>
<td><code>test_fid_modem_states_invisible_to_tick_10ms</code></td>
<td><span class="file-ref">test_fidelity.c:299</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: Handler ordering (1 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-D8A</span></td>
<td>B→ACTSTART falls through to ACTSTART handler in same tick</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State=STATE_B, ActivationMode=0 (expired)</li><li class="step-when"><span class="step-keyword">When</span> tick_10ms with PILOT_9V</li><li class="step-then"><span class="step-keyword">Then</span> State=STATE_ACTSTART, ActivationTimer=3</li></ul></td>
<td><code>test_fid_b_to_actstart_falls_through</code></td>
<td><span class="file-ref">test_fidelity.c:327</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Fidelity: Config field (2 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-FID-CFG-A</span></td>
<td>Socket mode (Config=0) caps ChargeCurrent by MaxCapacity</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Config=0, MaxCurrent=25, MaxCapacity=16, STATE_C</li><li class="step-when"><span class="step-keyword">When</span> calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent=160 (capped by MaxCapacity)</li></ul></td>
<td><code>test_fid_config_socket_caps_by_maxcapacity</code></td>
<td><span class="file-ref">test_fidelity.c:351</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-FID-CFG-B</span></td>
<td>Fixed cable mode (Config=1) does NOT cap by MaxCapacity</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Config=1, MaxCurrent=25, MaxCapacity=16, STATE_C</li><li class="step-when"><span class="step-keyword">When</span> calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent=250 (MaxCurrent * 10, not capped)</li></ul></td>
<td><code>test_fid_config_fixed_cable_no_maxcapacity_cap</code></td>
<td><span class="file-ref">test_fidelity.c:372</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">HTTP API Color Parsing (3 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-API-001</span></td>
<td>Valid RGB color values are accepted</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Integer values for R, G, B</li><li class="step-when"><span class="step-keyword">When</span> All values are in 0..255</li><li class="step-then"><span class="step-keyword">Then</span> http_api_parse_color returns true with correct output</li></ul></td>
<td><code>test_color_valid</code></td>
<td><span class="file-ref">test_http_api.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-001</span></td>
<td>Zero RGB values are accepted</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_zero</code></td>
<td><span class="file-ref">test_http_api.c:30</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-001</span></td>
<td>Maximum RGB values are accepted</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_max</code></td>
<td><span class="file-ref">test_http_api.c:41</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">HTTP API Input Validation (24 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-API-002</span></td>
<td>RGB value above 255 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_out_of_range</code></td>
<td><span class="file-ref">test_http_api.c:52</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-002</span></td>
<td>Negative RGB value is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_negative</code></td>
<td><span class="file-ref">test_http_api.c:62</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-004</span></td>
<td>Override current below minimum is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_below_min</code></td>
<td><span class="file-ref">test_http_api.c:111</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-004</span></td>
<td>Override current above maximum is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_above_max</code></td>
<td><span class="file-ref">test_http_api.c:120</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-004</span></td>
<td>Override current on slave is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_slave</code></td>
<td><span class="file-ref">test_http_api.c:129</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-005</span></td>
<td>Current min below 6A is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_min_too_low</code></td>
<td><span class="file-ref">test_http_api.c:158</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-005</span></td>
<td>Current min above 16A is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_min_too_high</code></td>
<td><span class="file-ref">test_http_api.c:167</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-005</span></td>
<td>Current min on slave is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_min_slave</code></td>
<td><span class="file-ref">test_http_api.c:176</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-006</span></td>
<td>Max sum mains between 1-9 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_gap</code></td>
<td><span class="file-ref">test_http_api.c:214</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-006</span></td>
<td>Max sum mains above 600 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_too_high</code></td>
<td><span class="file-ref">test_http_api.c:223</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-006</span></td>
<td>Max sum mains on slave is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_slave</code></td>
<td><span class="file-ref">test_http_api.c:232</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-007</span></td>
<td>Stop timer above 60 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_stop_timer_too_high</code></td>
<td><span class="file-ref">test_http_api.c:261</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-007</span></td>
<td>Negative stop timer is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_stop_timer_negative</code></td>
<td><span class="file-ref">test_http_api.c:270</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-008</span></td>
<td>Solar start current above 48 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_solar_start_too_high</code></td>
<td><span class="file-ref">test_http_api.c:299</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-009</span></td>
<td>Solar max import above 48 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_solar_import_too_high</code></td>
<td><span class="file-ref">test_http_api.c:319</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-011</span></td>
<td>PrioStrategy value 3 is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_too_high</code></td>
<td><span class="file-ref">test_http_api.c:360</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-011</span></td>
<td>PrioStrategy negative value is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_negative</code></td>
<td><span class="file-ref">test_http_api.c:369</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-011</span></td>
<td>PrioStrategy on slave is rejected</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A slave EVSE (load_bl=2)</li><li class="step-when"><span class="step-keyword">When</span> prio_strategy is 0 (valid value)</li><li class="step-then"><span class="step-keyword">Then</span> Validation fails because slaves cannot set scheduling</li></ul></td>
<td><code>test_prio_strategy_slave</code></td>
<td><span class="file-ref">test_http_api.c:378</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-012</span></td>
<td>RotationInterval in gap (1-29) is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_gap</code></td>
<td><span class="file-ref">test_http_api.c:422</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-012</span></td>
<td>RotationInterval above maximum is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_too_high</code></td>
<td><span class="file-ref">test_http_api.c:431</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-012</span></td>
<td>RotationInterval on slave is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_slave</code></td>
<td><span class="file-ref">test_http_api.c:440</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-013</span></td>
<td>IdleTimeout below minimum (29) is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_too_low</code></td>
<td><span class="file-ref">test_http_api.c:481</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-013</span></td>
<td>IdleTimeout above maximum (301) is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_too_high</code></td>
<td><span class="file-ref">test_http_api.c:490</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-013</span></td>
<td>IdleTimeout on slave is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_slave</code></td>
<td><span class="file-ref">test_http_api.c:499</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">HTTP API Validation (23 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-API-003</span></td>
<td>Override current zero is always valid (disables override)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_zero</code></td>
<td><span class="file-ref">test_http_api.c:74</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-003</span></td>
<td>Override current within range is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_valid</code></td>
<td><span class="file-ref">test_http_api.c:83</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-003</span></td>
<td>Override current at minimum boundary is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_at_min</code></td>
<td><span class="file-ref">test_http_api.c:93</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-003</span></td>
<td>Override current at maximum boundary is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_override_current_at_max</code></td>
<td><span class="file-ref">test_http_api.c:102</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-005</span></td>
<td>Current min at boundary (6A) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_min_valid</code></td>
<td><span class="file-ref">test_http_api.c:140</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-005</span></td>
<td>Current min at 16A is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_min_max</code></td>
<td><span class="file-ref">test_http_api.c:149</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-006</span></td>
<td>Max sum mains zero disables limit</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_zero</code></td>
<td><span class="file-ref">test_http_api.c:187</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-006</span></td>
<td>Max sum mains at minimum (10A) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_min</code></td>
<td><span class="file-ref">test_http_api.c:196</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-006</span></td>
<td>Max sum mains at maximum (600A) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_max</code></td>
<td><span class="file-ref">test_http_api.c:205</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-007</span></td>
<td>Stop timer at zero is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_stop_timer_zero</code></td>
<td><span class="file-ref">test_http_api.c:243</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-007</span></td>
<td>Stop timer at max (60) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_stop_timer_max</code></td>
<td><span class="file-ref">test_http_api.c:252</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-008</span></td>
<td>Solar start current at 0 is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_solar_start_zero</code></td>
<td><span class="file-ref">test_http_api.c:281</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-008</span></td>
<td>Solar start current at 48 is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_solar_start_max</code></td>
<td><span class="file-ref">test_http_api.c:290</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-009</span></td>
<td>Solar max import at 0 is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_solar_import_zero</code></td>
<td><span class="file-ref">test_http_api.c:310</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-011</span></td>
<td>PrioStrategy MODBUS_ADDR (0) is valid on master</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A master EVSE (load_bl=0)</li><li class="step-when"><span class="step-keyword">When</span> prio_strategy is 0</li><li class="step-then"><span class="step-keyword">Then</span> Validation passes</li></ul></td>
<td><code>test_prio_strategy_valid_0</code></td>
<td><span class="file-ref">test_http_api.c:330</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-011</span></td>
<td>PrioStrategy FIRST_CONNECTED (1) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_valid_1</code></td>
<td><span class="file-ref">test_http_api.c:342</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-011</span></td>
<td>PrioStrategy LAST_CONNECTED (2) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_valid_2</code></td>
<td><span class="file-ref">test_http_api.c:351</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-012</span></td>
<td>RotationInterval 0 (disabled) is valid</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A master EVSE (load_bl=0)</li><li class="step-when"><span class="step-keyword">When</span> rotation_interval is 0</li><li class="step-then"><span class="step-keyword">Then</span> Validation passes</li></ul></td>
<td><code>test_rotation_interval_zero</code></td>
<td><span class="file-ref">test_http_api.c:392</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-012</span></td>
<td>RotationInterval at minimum (30) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_min</code></td>
<td><span class="file-ref">test_http_api.c:404</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-012</span></td>
<td>RotationInterval at maximum (1440) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_max</code></td>
<td><span class="file-ref">test_http_api.c:413</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-013</span></td>
<td>IdleTimeout at minimum (30) is valid</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A master EVSE (load_bl=0)</li><li class="step-when"><span class="step-keyword">When</span> idle_timeout is 30</li><li class="step-then"><span class="step-keyword">Then</span> Validation passes</li></ul></td>
<td><code>test_idle_timeout_min</code></td>
<td><span class="file-ref">test_http_api.c:451</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-013</span></td>
<td>IdleTimeout at default (60) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_default</code></td>
<td><span class="file-ref">test_http_api.c:463</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-013</span></td>
<td>IdleTimeout at maximum (300) is valid</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_max</code></td>
<td><span class="file-ref">test_http_api.c:472</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">HTTP API Settings Validation (7 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-API-010</span></td>
<td>Valid settings request passes validation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A settings request with valid current_min and override_current</li><li class="step-when"><span class="step-keyword">When</span> Validated against current limits</li><li class="step-then"><span class="step-keyword">Then</span> No errors are returned</li></ul></td>
<td><code>test_validate_settings_valid</code></td>
<td><span class="file-ref">test_http_api.c:510</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-010</span></td>
<td>Invalid current_min in combined request</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_validate_settings_invalid_min</code></td>
<td><span class="file-ref">test_http_api.c:531</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-010</span></td>
<td>Multiple invalid fields</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_validate_settings_multiple_errors</code></td>
<td><span class="file-ref">test_http_api.c:548</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-010</span></td>
<td>Empty request passes validation</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_validate_settings_empty</code></td>
<td><span class="file-ref">test_http_api.c:566</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-010</span></td>
<td>Slave restrictions applied</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_validate_settings_slave_restrictions</code></td>
<td><span class="file-ref">test_http_api.c:580</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-014</span></td>
<td>Valid scheduling settings in combined request</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A settings request with valid scheduling fields</li><li class="step-when"><span class="step-keyword">When</span> Validated on master (load_bl=1)</li><li class="step-then"><span class="step-keyword">Then</span> No errors are returned</li></ul></td>
<td><code>test_validate_settings_scheduling_valid</code></td>
<td><span class="file-ref">test_http_api.c:596</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-API-014</span></td>
<td>Invalid scheduling settings on slave</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A settings request with scheduling fields</li><li class="step-when"><span class="step-keyword">When</span> Validated on slave (load_bl=2)</li><li class="step-then"><span class="step-keyword">Then</span> All three scheduling fields produce errors</li></ul></td>
<td><code>test_validate_settings_scheduling_slave</code></td>
<td><span class="file-ref">test_http_api.c:619</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">LED Status Indication (15 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-LED-001</span></td>
<td>RCM tripped error produces red flashing pattern on ESP32</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ErrorFlags has RCM_TRIPPED set on ESP32 platform</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called repeatedly</li><li class="step-then"><span class="step-keyword">Then</span> LED alternates between red and off</li></ul></td>
<td><code>test_error_rcm_tripped_esp32</code></td>
<td><span class="file-ref">test_led_color.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-001</span></td>
<td>CT_NOCOMM error shows red flashing</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ErrorFlags has CT_NOCOMM set</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called multiple times</li><li class="step-then"><span class="step-keyword">Then</span> LED flashes red</li></ul></td>
<td><code>test_error_ct_nocomm</code></td>
<td><span class="file-ref">test_led_color.c:82</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-001</span></td>
<td>TEMP_HIGH error shows red flashing</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ErrorFlags has TEMP_HIGH set</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED flashes red</li></ul></td>
<td><code>test_error_temp_high</code></td>
<td><span class="file-ref">test_led_color.c:105</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-001</span></td>
<td>CH32 RCM mismatch with no test counter shows error</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> CH32 platform with RCM_TRIPPED set but not RCM_TEST, counter=0</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows red (error condition)</li></ul></td>
<td><code>test_error_ch32_rcm_mismatch</code></td>
<td><span class="file-ref">test_led_color.c:126</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-001</span></td>
<td>CH32 RCM test in progress does not show error flash</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> CH32 platform with RCM_TRIPPED set, counter &gt; 0 (test running)</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED does NOT show rapid red error flash (enters waiting blink instead)</li></ul></td>
<td><code>test_no_error_ch32_rcm_test_active</code></td>
<td><span class="file-ref">test_led_color.c:149</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-002</span></td>
<td>Access OFF shows off color</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Access status is OFF, no custom button</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows ColorOff values</li></ul></td>
<td><code>test_access_off_default</code></td>
<td><span class="file-ref">test_led_color.c:181</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-002</span></td>
<td>MODEM_DENIED state shows off color</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State is STATE_MODEM_DENIED, access ON</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows ColorOff values (same as access OFF)</li></ul></td>
<td><code>test_modem_denied_shows_off</code></td>
<td><span class="file-ref">test_led_color.c:224</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-003</span></td>
<td>Solar mode with charge delay shows slow blink</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Solar mode, ChargeDelay &gt; 0, no errors</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called repeatedly</li><li class="step-then"><span class="step-keyword">Then</span> LED blinks with solar color (orange)</li></ul></td>
<td><code>test_waiting_solar_blink</code></td>
<td><span class="file-ref">test_led_color.c:247</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-003</span></td>
<td>Smart mode waiting shows smart color blink</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Smart mode, ChargeDelay &gt; 0</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called when LED is on</li><li class="step-then"><span class="step-keyword">Then</span> Color matches ColorSmart</li></ul></td>
<td><code>test_waiting_smart_color</code></td>
<td><span class="file-ref">test_led_color.c:271</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-005</span></td>
<td>State A shows dimmed LED</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State A, Normal mode, no errors</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows dimmed green (STATE_A_LED_BRIGHTNESS)</li></ul></td>
<td><code>test_state_a_dimmed</code></td>
<td><span class="file-ref">test_led_color.c:320</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-005</span></td>
<td>State B shows full brightness LED</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State B, Normal mode, no errors</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows full brightness green</li></ul></td>
<td><code>test_state_b_full_brightness</code></td>
<td><span class="file-ref">test_led_color.c:340</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-005</span></td>
<td>State B1 shows full brightness (same as B)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State B1, Normal mode</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows full brightness green</li></ul></td>
<td><code>test_state_b1_full_brightness</code></td>
<td><span class="file-ref">test_led_color.c:359</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-005</span></td>
<td>State B sets led_count to 128 for smooth C transition</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State B entered</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> led_count is set to 128</li></ul></td>
<td><code>test_state_b_sets_count_128</code></td>
<td><span class="file-ref">test_led_color.c:378</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-006</span></td>
<td>State C shows breathing animation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State C, Normal mode</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called multiple times</li><li class="step-then"><span class="step-keyword">Then</span> LED brightness varies (breathing effect)</li></ul></td>
<td><code>test_state_c_breathing</code></td>
<td><span class="file-ref">test_led_color.c:395</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-006</span></td>
<td>State C Solar mode has slower breathing</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State C, Solar mode</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> led_count increments by 1 per call (vs 2 for other modes)</li></ul></td>
<td><code>test_state_c_solar_slower</code></td>
<td><span class="file-ref">test_led_color.c:418</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">LED Color Configuration (4 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-LED-004</span></td>
<td>Custom button active when access OFF shows custom color</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Access OFF and CustomButton is true</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows ColorCustom values</li></ul></td>
<td><code>test_access_off_custom_button</code></td>
<td><span class="file-ref">test_led_color.c:204</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-004</span></td>
<td>Custom button waiting shows custom color</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Custom button active, ChargeDelay &gt; 0</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called when LED is on</li><li class="step-then"><span class="step-keyword">Then</span> Color matches ColorCustom</li></ul></td>
<td><code>test_waiting_custom_button</code></td>
<td><span class="file-ref">test_led_color.c:294</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-004</span></td>
<td>Solar mode State A shows solar orange (dimmed)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State A, Solar mode</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows orange tint at STATE_A brightness</li></ul></td>
<td><code>test_state_a_solar_color</code></td>
<td><span class="file-ref">test_led_color.c:445</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LED-004</span></td>
<td>Custom button overrides mode color in State B</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> State B, Normal mode, CustomButton true</li><li class="step-when"><span class="step-keyword">When</span> led_compute_color is called</li><li class="step-then"><span class="step-keyword">Then</span> LED shows custom blue at full brightness</li></ul></td>
<td><code>test_state_b_custom_override</code></td>
<td><span class="file-ref">test_led_color.c:466</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Load Balancing (15 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-LB-001</span></td>
<td>Single standalone EVSE receives full MaxCurrent allocation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A standalone EVSE (LoadBl=0) in STATE_C with MaxCurrent=16A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced is set to 160 (16A in tenths)</li></ul></td>
<td><code>test_single_evse_gets_full_current</code></td>
<td><span class="file-ref">test_load_balancing.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-002</span></td>
<td>Two EVSEs receive equal current distribution</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs are charging as master (LoadBl=1) with equal BalancedMax</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Both EVSEs receive equal Balanced current allocations</li></ul></td>
<td><code>test_two_evse_equal_distribution</code></td>
<td><span class="file-ref">test_load_balancing.c:66</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-003</span></td>
<td>Two EVSEs respect MaxCircuit total capacity limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs are charging with MaxCircuit=16A total</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Each EVSE receives at most half the circuit capacity</li></ul></td>
<td><code>test_two_evse_respects_max_circuit</code></td>
<td><span class="file-ref">test_load_balancing.c:82</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-004</span></td>
<td>Individual EVSE BalancedMax caps its current allocation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs are charging with EVSE 1 having BalancedMax=60 (6A)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE 1 Balanced is capped at its BalancedMax of 60</li></ul></td>
<td><code>test_balanced_max_caps_individual</code></td>
<td><span class="file-ref">test_load_balancing.c:101</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-006</span></td>
<td>Each active EVSE receives at least MinCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs are both in STATE_A (disconnected) as master</li><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs are charging with MinCurrent=6A and limited total capacity</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent and SolarStopTimer are reset to 0</li><li class="step-then"><span class="step-keyword">Then</span> Each charging EVSE with non-zero allocation gets at least MinCurrent*10</li></ul></td>
<td><code>test_minimum_current_enforced</code></td>
<td><span class="file-ref">test_load_balancing.c:121</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-007</span></td>
<td>New EVSE joining (mod=1) triggers full recalculation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs in MODE_SMART with existing current distribution</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with mod=1 (new EVSE joining)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced is recalculated from scratch (different from previous value)</li></ul></td>
<td><code>test_mod1_new_evse_recalculates</code></td>
<td><span class="file-ref">test_load_balancing.c:167</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-008</span></td>
<td>OCPP current limit reduces ChargeCurrent below MaxCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A standalone EVSE with OcppCurrentLimit=10A and MaxCurrent=16A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is capped at 100 (10A in tenths) or below</li></ul></td>
<td><code>test_ocpp_limit_reduces_charge_current</code></td>
<td><span class="file-ref">test_load_balancing.c:189</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-009</span></td>
<td>OCPP current limit below MinCurrent zeros out ChargeCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A standalone EVSE with OcppCurrentLimit=3A and MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 0 (below minimum, cannot charge)</li></ul></td>
<td><code>test_ocpp_limit_below_min_zeros_current</code></td>
<td><span class="file-ref">test_load_balancing.c:215</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-010</span></td>
<td>OverrideCurrent takes precedence over calculated ChargeCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A standalone EVSE with OverrideCurrent=80 (8A) and MaxCurrent=16A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 80 (override value)</li></ul></td>
<td><code>test_override_current_takes_precedence</code></td>
<td><span class="file-ref">test_load_balancing.c:242</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-011</span></td>
<td>Current shortage increments NoCurrent counter</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs in MODE_SMART with mains heavily loaded and low MaxMains</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with insufficient capacity</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent counter is incremented above 0</li></ul></td>
<td><code>test_shortage_increments_nocurrent</code></td>
<td><span class="file-ref">test_load_balancing.c:269</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-012</span></td>
<td>No current shortage clears NoCurrent counter</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs in MODE_SMART with low mains load and high MaxMains</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with sufficient capacity</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent counter is cleared to 0</li></ul></td>
<td><code>test_no_shortage_clears_nocurrent</code></td>
<td><span class="file-ref">test_load_balancing.c:293</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-013</span></td>
<td>Open grid relay caps IsetBalanced at GridRelayMaxSumMains per phase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A standalone EVSE in MODE_SMART with GridRelayOpen=true and 3 phases</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced is capped at GridRelayMaxSumMains*10/3</li></ul></td>
<td><code>test_grid_relay_limits_current</code></td>
<td><span class="file-ref">test_load_balancing.c:317</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-014</span></td>
<td>Node EVSE requests COMM_C instead of transitioning directly to STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is configured as a node (LoadBl=2) in STATE_B with DiodeCheck passed</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal is sustained for 500ms (vehicle requests charge)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_COMM_C (requesting master permission to charge)</li></ul></td>
<td><code>test_node_requests_comm_c</code></td>
<td><span class="file-ref">test_load_balancing.c:353</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-F1A</span></td>
<td>Socket mode (Config=0) caps ChargeCurrent by MaxCapacity</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Config=0 (Socket), MaxCurrent=25, MaxCapacity=16, STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is capped at 160 (MaxCapacity * 10)</li></ul></td>
<td><code>test_config_socket_caps_by_maxcapacity</code></td>
<td><span class="file-ref">test_load_balancing.c:381</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-F1B</span></td>
<td>Fixed Cable mode (Config=1) does NOT cap by MaxCapacity</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Config=1 (Fixed Cable), MaxCurrent=25, MaxCapacity=16, STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is 250 (MaxCurrent * 10), not capped by MaxCapacity</li></ul></td>
<td><code>test_config_fixed_cable_no_maxcapacity_cap</code></td>
<td><span class="file-ref">test_load_balancing.c:408</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Meter Timeout &amp; Recovery (12 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-METER-001</span></td>
<td>CT_NOCOMM error is set on timeout and cleared when communication restores</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode standalone with MainsMeterType=1 and MainsMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick sets CT_NOCOMM, then MainsMeterTimeout is restored to 5 and another tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM is set after the first tick and cleared after the second tick</li></ul></td>
<td><code>test_ct_nocomm_set_then_restored</code></td>
<td><span class="file-ref">test_meter_recovery.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-002</span></td>
<td>EV_NOCOMM error is set on timeout and cleared when communication restores</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode with EVMeterType=1 and EVMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick sets EV_NOCOMM, then EVMeterTimeout is restored to 10 and another tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EV_NOCOMM is set after the first tick and cleared after the second tick</li></ul></td>
<td><code>test_ev_nocomm_set_then_restored</code></td>
<td><span class="file-ref">test_meter_recovery.c:51</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-003</span></td>
<td>Both CT_NOCOMM and EV_NOCOMM can be set simultaneously and recover independently</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode with both MainsMeterTimeout=0 and EVMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> Both timeouts expire, then mains meter is restored first, then EV meter is restored</li><li class="step-then"><span class="step-keyword">Then</span> Each NOCOMM flag is set and cleared independently as its respective meter recovers</li></ul></td>
<td><code>test_both_ct_and_ev_nocomm_simultaneously</code></td>
<td><span class="file-ref">test_meter_recovery.c:77</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-004</span></td>
<td>Mains meter timeout during STATE_C triggers transition to STATE_C1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode standalone in STATE_C with high mains load and MainsMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM is set and EVSE transitions from STATE_C to STATE_C1 (charging suspended)</li></ul></td>
<td><code>test_mains_timeout_during_state_c</code></td>
<td><span class="file-ref">test_meter_recovery.c:118</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-005</span></td>
<td>EV meter timeout during STATE_C triggers transition to STATE_C1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode standalone in STATE_C with EVMeterType=1 and EVMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EV_NOCOMM is set and EVSE transitions from STATE_C to STATE_C1 (charging suspended)</li></ul></td>
<td><code>test_ev_timeout_during_state_c</code></td>
<td><span class="file-ref">test_meter_recovery.c:145</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-006</span></td>
<td>MainsMeter timeout on node sets CT_NOCOMM regardless of operating mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a node (LoadBl=3) in Normal mode with MainsMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM is set because nodes do not have the MODE_NORMAL guard for timeout checks</li></ul></td>
<td><code>test_mains_timeout_on_node</code></td>
<td><span class="file-ref">test_meter_recovery.c:175</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-007</span></td>
<td>MainsMeter timeout on standalone in Normal mode does not set CT_NOCOMM</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone (LoadBl=0) in MODE_NORMAL with MainsMeterType=1 and MainsMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM is not set because the MODE_NORMAL guard skips the timeout check for master/standalone</li></ul></td>
<td><code>test_mains_timeout_master_normal_mode_ignored</code></td>
<td><span class="file-ref">test_meter_recovery.c:196</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-008</span></td>
<td>No EV meter installed continuously resets EVMeterTimeout to COMM_EVTIMEOUT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EVMeterType=0 (no EV meter installed) with EVMeterTimeout artificially lowered</li><li class="step-when"><span class="step-keyword">When</span> 1-second ticks occur even with EVMeterTimeout set to 0</li><li class="step-then"><span class="step-keyword">Then</span> EVMeterTimeout is always reset to COMM_EVTIMEOUT and EV_NOCOMM is never set</li></ul></td>
<td><code>test_no_ev_meter_resets_timeout_continuously</code></td>
<td><span class="file-ref">test_meter_recovery.c:221</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-009</span></td>
<td>No mains meter type and standalone resets MainsMeterTimeout to COMM_TIMEOUT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has MainsMeterType=0 and LoadBl=0 with MainsMeterTimeout artificially lowered to 3</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> MainsMeterTimeout is reset to COMM_TIMEOUT because no mains meter is configured</li></ul></td>
<td><code>test_no_mains_meter_resets_timeout_continuously</code></td>
<td><span class="file-ref">test_meter_recovery.c:248</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-010</span></td>
<td>Temperature recovery requires strictly below hysteresis boundary</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has TEMP_HIGH error with maxTemp=65 and TempEVSE=55 (exactly at maxTemp-10)</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH error remains set because recovery requires TempEVSE &lt; (maxTemp - 10), not &lt;=</li></ul></td>
<td><code>test_temp_recovery_exactly_at_boundary</code></td>
<td><span class="file-ref">test_meter_recovery.c:269</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-011</span></td>
<td>Temperature recovery clears TEMP_HIGH when one degree below hysteresis boundary</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has TEMP_HIGH error with maxTemp=65 and TempEVSE=54 (one below maxTemp-10)</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> TEMP_HIGH error is cleared because 54 &lt; 55 (maxTemp - 10) satisfies the recovery condition</li></ul></td>
<td><code>test_temp_recovery_one_below_boundary</code></td>
<td><span class="file-ref">test_meter_recovery.c:288</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-METER-012</span></td>
<td>Mains meter countdown sequence from 3 to 0 then CT_NOCOMM on next tick</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode standalone with MainsMeterType=1 and MainsMeterTimeout=3</li><li class="step-when"><span class="step-keyword">When</span> Four consecutive 1-second ticks occur decrementing the timeout</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM remains clear during countdown (3 to 0) and is set on the tick after reaching 0</li></ul></td>
<td><code>test_mains_meter_countdown_to_error</code></td>
<td><span class="file-ref">test_meter_recovery.c:309</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Modem / ISO15118 Negotiation (29 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MODEM-001</span></td>
<td>Entering MODEM_REQUEST disconnects the pilot signal</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_REQUEST</li><li class="step-then"><span class="step-keyword">Then</span> pilot_connected is false</li></ul></td>
<td><code>test_modem_request_disconnects_pilot</code></td>
<td><span class="file-ref">test_modem_states.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-002</span></td>
<td>Entering MODEM_REQUEST sets PWM to off (+12V)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_REQUEST</li><li class="step-then"><span class="step-keyword">Then</span> PWM duty is set to 1024 (off / +12V constant)</li></ul></td>
<td><code>test_modem_request_pwm_off</code></td>
<td><span class="file-ref">test_modem_states.c:38</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-003</span></td>
<td>Entering MODEM_REQUEST ensures contactors are open</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_REQUEST</li><li class="step-then"><span class="step-keyword">Then</span> Both contactor1 and contactor2 are off (open)</li></ul></td>
<td><code>test_modem_request_contactors_off</code></td>
<td><span class="file-ref">test_modem_states.c:52</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-004</span></td>
<td>MODEM_REQUEST transitions to MODEM_WAIT after timer expires</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_REQUEST with ToModemWaitStateTimer=0</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_MODEM_WAIT</li></ul></td>
<td><code>test_modem_request_to_wait_on_timer</code></td>
<td><span class="file-ref">test_modem_states.c:67</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-005</span></td>
<td>Modem states are NOT handled in tick_10ms (original behavior)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_REQUEST</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received during tick_10ms</li><li class="step-then"><span class="step-keyword">Then</span> The state stays MODEM_REQUEST (modem is managed only by tick_1s timers)</li></ul></td>
<td><code>test_modem_request_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_modem_states.c:83</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-006</span></td>
<td>Entering MODEM_WAIT sets 5% PWM duty cycle for ISO15118 signalling</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_WAIT</li><li class="step-then"><span class="step-keyword">Then</span> PWM duty is set to 51 (5% duty cycle)</li></ul></td>
<td><code>test_modem_wait_5pct_duty</code></td>
<td><span class="file-ref">test_modem_states.c:100</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-007</span></td>
<td>Entering MODEM_WAIT reconnects the pilot signal</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_WAIT</li><li class="step-then"><span class="step-keyword">Then</span> pilot_connected is true</li></ul></td>
<td><code>test_modem_wait_pilot_connected</code></td>
<td><span class="file-ref">test_modem_states.c:114</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-008</span></td>
<td>Entering MODEM_WAIT sets ToModemDoneStateTimer to 60 seconds</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_WAIT</li><li class="step-then"><span class="step-keyword">Then</span> ToModemDoneStateTimer is set to 60</li></ul></td>
<td><code>test_modem_wait_timer_set</code></td>
<td><span class="file-ref">test_modem_states.c:128</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-009</span></td>
<td>MODEM_WAIT transitions to MODEM_DONE after 60-second timeout</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_WAIT with 60-second timer</li><li class="step-when"><span class="step-keyword">When</span> 61 second ticks occur (60 to decrement to 0, 1 more to fire transition)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_MODEM_DONE</li></ul></td>
<td><code>test_modem_wait_to_done_after_timeout</code></td>
<td><span class="file-ref">test_modem_states.c:142</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-010</span></td>
<td>MODEM_WAIT is NOT handled in tick_10ms (original behavior)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_WAIT</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received during tick_10ms</li><li class="step-then"><span class="step-keyword">Then</span> The state stays MODEM_WAIT (modem is managed only by tick_1s timers)</li></ul></td>
<td><code>test_modem_wait_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_modem_states.c:160</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-011</span></td>
<td>Entering MODEM_DONE disconnects the pilot signal</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_DONE</li><li class="step-then"><span class="step-keyword">Then</span> pilot_connected is false</li></ul></td>
<td><code>test_modem_done_disconnects_pilot</code></td>
<td><span class="file-ref">test_modem_states.c:177</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-012</span></td>
<td>Entering MODEM_DONE sets LeaveModemDoneStateTimer to 5 seconds</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_MODEM_DONE</li><li class="step-then"><span class="step-keyword">Then</span> LeaveModemDoneStateTimer is set to 5</li></ul></td>
<td><code>test_modem_done_timer_set</code></td>
<td><span class="file-ref">test_modem_states.c:191</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-013</span></td>
<td>MODEM_DONE transitions to STATE_B after 5-second timer with ModemStage=1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_DONE with 5-second timer</li><li class="step-when"><span class="step-keyword">When</span> 6 second ticks occur (5 to decrement to 0, 1 more to fire transition)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B and ModemStage is set to 1</li></ul></td>
<td><code>test_modem_done_to_B_after_timer</code></td>
<td><span class="file-ref">test_modem_states.c:205</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-014</span></td>
<td>MODEM_DONE is NOT handled in tick_10ms (original behavior)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_DONE</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received during tick_10ms</li><li class="step-then"><span class="step-keyword">Then</span> The state stays MODEM_DONE (modem is managed only by tick_1s timers)</li></ul></td>
<td><code>test_modem_done_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_modem_states.c:223</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-015</span></td>
<td>MODEM_DENIED transitions to STATE_A after timer expires</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_DENIED with LeaveModemDeniedStateTimer=3</li><li class="step-when"><span class="step-keyword">When</span> 4 second ticks occur (3 to decrement to 0, 1 more to fire transition)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_A</li></ul></td>
<td><code>test_modem_denied_to_A_after_timer</code></td>
<td><span class="file-ref">test_modem_states.c:240</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-016</span></td>
<td>MODEM_DENIED is NOT handled in tick_10ms (original behavior)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_MODEM_DENIED with timer still running</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received during tick_10ms</li><li class="step-then"><span class="step-keyword">Then</span> The state stays MODEM_DENIED (modem is managed only by tick_1s timers)</li></ul></td>
<td><code>test_modem_denied_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_modem_states.c:258</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M1A</span></td>
<td>MODEM_WAIT timer=1 does not transition immediately on decrement</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_MODEM_WAIT with ToModemDoneStateTimer=1</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs (timer decrements to 0)</li><li class="step-when"><span class="step-keyword">When</span> Another second tick occurs (timer is now 0, else branch fires)</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE stays in STATE_MODEM_WAIT (does not yet transition to MODEM_DONE)</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_MODEM_DONE</li></ul></td>
<td><code>test_modem_wait_timer_1_no_immediate_transition</code></td>
<td><span class="file-ref">test_modem_states.c:276</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M1B</span></td>
<td>MODEM_DONE timer=1 does not transition immediately on decrement</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_MODEM_DONE with LeaveModemDoneStateTimer=1</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs (timer decrements to 0)</li><li class="step-when"><span class="step-keyword">When</span> Another second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE stays in STATE_MODEM_DONE</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_B (EVCCID accepted)</li></ul></td>
<td><code>test_modem_done_timer_1_no_immediate_transition</code></td>
<td><span class="file-ref">test_modem_states.c:299</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M1C</span></td>
<td>MODEM_DENIED timer=1 does not transition immediately on decrement</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_MODEM_DENIED with LeaveModemDeniedStateTimer=1</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs (timer decrements to 0)</li><li class="step-when"><span class="step-keyword">When</span> Another second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE stays in STATE_MODEM_DENIED</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_A</li></ul></td>
<td><code>test_modem_denied_timer_1_no_immediate_transition</code></td>
<td><span class="file-ref">test_modem_states.c:320</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M2A</span></td>
<td>DisconnectTimeCounter starts on STATE_A entry when modem enabled</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=true, DisconnectTimeCounter=-1 (disabled)</li><li class="step-when"><span class="step-keyword">When</span> State is set to STATE_A</li><li class="step-then"><span class="step-keyword">Then</span> DisconnectTimeCounter is set to 0 (started)</li></ul></td>
<td><code>test_disconnect_counter_starts_on_state_a</code></td>
<td><span class="file-ref">test_modem_states.c:343</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M2B</span></td>
<td>DisconnectTimeCounter disabled on MODEM_REQUEST entry</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> DisconnectTimeCounter=5 (running)</li><li class="step-when"><span class="step-keyword">When</span> State is set to STATE_MODEM_REQUEST</li><li class="step-then"><span class="step-keyword">Then</span> DisconnectTimeCounter is set to -1 (disabled)</li></ul></td>
<td><code>test_disconnect_counter_disabled_on_modem_request</code></td>
<td><span class="file-ref">test_modem_states.c:358</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M2C</span></td>
<td>DisconnectTimeCounter disabled on MODEM_DONE entry</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> DisconnectTimeCounter=5 (running)</li><li class="step-when"><span class="step-keyword">When</span> State is set to STATE_MODEM_DONE</li><li class="step-then"><span class="step-keyword">Then</span> DisconnectTimeCounter is set to -1 (disabled)</li></ul></td>
<td><code>test_disconnect_counter_disabled_on_modem_done</code></td>
<td><span class="file-ref">test_modem_states.c:373</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M2D</span></td>
<td>DisconnectTimeCounter is NOT incremented in tick_1s (handled by firmware wrapper)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=true, DisconnectTimeCounter=0</li><li class="step-when"><span class="step-keyword">When</span> tick_1s occurs</li><li class="step-then"><span class="step-keyword">Then</span> DisconnectTimeCounter stays 0 (firmware wrapper handles increment + pilot check)</li></ul></td>
<td><code>test_disconnect_counter_increments_in_tick_1s</code></td>
<td><span class="file-ref">test_modem_states.c:388</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-M2E</span></td>
<td>DisconnectTimeCounter does not increment when disabled (-1)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=true, DisconnectTimeCounter=-1</li><li class="step-when"><span class="step-keyword">When</span> tick_1s occurs</li><li class="step-then"><span class="step-keyword">Then</span> DisconnectTimeCounter remains -1</li></ul></td>
<td><code>test_disconnect_counter_stays_disabled</code></td>
<td><span class="file-ref">test_modem_states.c:403</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-EVCCID-001</span></td>
<td>Empty RequiredEVCCID allows any vehicle</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODEM_DONE, LeaveModemDoneStateTimer expired, RequiredEVCCID=&quot;&quot;</li><li class="step-when"><span class="step-keyword">When</span> tick_1s processes MODEM_DONE timer expiry</li><li class="step-then"><span class="step-keyword">Then</span> Transitions to STATE_B with ModemStage=1</li></ul></td>
<td><code>test_evccid_empty_required_allows_any</code></td>
<td><span class="file-ref">test_modem_states.c:420</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-EVCCID-002</span></td>
<td>Matching EVCCID passes validation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODEM_DONE, timer expired, RequiredEVCCID matches EVCCID</li><li class="step-when"><span class="step-keyword">When</span> tick_1s processes timer expiry</li><li class="step-then"><span class="step-keyword">Then</span> Transitions to STATE_B with ModemStage=1</li></ul></td>
<td><code>test_evccid_matching_passes</code></td>
<td><span class="file-ref">test_modem_states.c:441</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-EVCCID-003</span></td>
<td>Mismatched EVCCID triggers MODEM_DENIED</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> MODEM_DONE, timer expired, RequiredEVCCID != EVCCID</li><li class="step-when"><span class="step-keyword">When</span> tick_1s processes timer expiry</li><li class="step-then"><span class="step-keyword">Then</span> Transitions to MODEM_DENIED, ModemStage=0, LeaveModemDeniedStateTimer=60</li></ul></td>
<td><code>test_evccid_mismatch_denied</code></td>
<td><span class="file-ref">test_modem_states.c:462</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-EVCCID-004</span></td>
<td>Full flow: EVCCID mismatch → DENIED → timeout → STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Modem flow reaches MODEM_DONE with wrong EVCCID</li><li class="step-when"><span class="step-keyword">When</span> Timer expires and EVCCID doesn&#x27;t match, then DENIED timer expires</li><li class="step-then"><span class="step-keyword">Then</span> MODEM_DENIED → STATE_A after 60+1 seconds</li></ul></td>
<td><code>test_evccid_mismatch_full_flow_to_a</code></td>
<td><span class="file-ref">test_modem_states.c:485</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODEM-017</span></td>
<td>Full modem negotiation flow: REQUEST -&gt; WAIT -&gt; DONE -&gt; STATE_B</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is initialised with basic configuration</li><li class="step-when"><span class="step-keyword">When</span> The modem negotiation proceeds through all stages with timers expiring</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions REQUEST-&gt;WAIT-&gt;DONE-&gt;B with ModemStage=1 and correct PWM/pilot at each stage</li></ul></td>
<td><code>test_full_modem_flow</code></td>
<td><span class="file-ref">test_modem_states.c:515</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">MQTT Command Parsing (27 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MQTT-001</span></td>
<td>Set mode to Normal via MQTT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/Mode with payload &quot;Normal&quot;</li><li class="step-then"><span class="step-keyword">Then</span> Command type is MQTT_CMD_MODE with mode MQTT_MODE_NORMAL</li></ul></td>
<td><code>test_mode_normal</code></td>
<td><span class="file-ref">test_mqtt_parser.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-001</span></td>
<td>Set mode to Solar via MQTT</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mode_solar</code></td>
<td><span class="file-ref">test_mqtt_parser.c:32</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-001</span></td>
<td>Set mode to Smart via MQTT</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mode_smart</code></td>
<td><span class="file-ref">test_mqtt_parser.c:43</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-001</span></td>
<td>Set mode to Off via MQTT</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mode_off</code></td>
<td><span class="file-ref">test_mqtt_parser.c:54</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-001</span></td>
<td>Set mode to Pause via MQTT</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mode_pause</code></td>
<td><span class="file-ref">test_mqtt_parser.c:65</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-003</span></td>
<td>CustomButton set to On</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_custom_button_on</code></td>
<td><span class="file-ref">test_mqtt_parser.c:90</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-003</span></td>
<td>CustomButton set to Off</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_custom_button_off</code></td>
<td><span class="file-ref">test_mqtt_parser.c:101</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-006</span></td>
<td>CP PWM override normal mode (-1)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cp_pwm_normal</code></td>
<td><span class="file-ref">test_mqtt_parser.c:192</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-006</span></td>
<td>CP PWM override disconnect (0)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cp_pwm_disconnect</code></td>
<td><span class="file-ref">test_mqtt_parser.c:203</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-006</span></td>
<td>CP PWM override max value (1024)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cp_pwm_max</code></td>
<td><span class="file-ref">test_mqtt_parser.c:213</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-009</span></td>
<td>Home battery current set</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_home_battery_current</code></td>
<td><span class="file-ref">test_mqtt_parser.c:370</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-009</span></td>
<td>Home battery current negative (discharging)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_home_battery_current_negative</code></td>
<td><span class="file-ref">test_mqtt_parser.c:381</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-011</span></td>
<td>Cable lock enabled</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cable_lock_enable</code></td>
<td><span class="file-ref">test_mqtt_parser.c:473</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-011</span></td>
<td>Cable lock disabled</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cable_lock_disable</code></td>
<td><span class="file-ref">test_mqtt_parser.c:484</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-011</span></td>
<td>Cable lock any non-&quot;1&quot; disables</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cable_lock_any_other</code></td>
<td><span class="file-ref">test_mqtt_parser.c:494</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-012</span></td>
<td>EnableC2 numeric value</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_enable_c2_numeric</code></td>
<td><span class="file-ref">test_mqtt_parser.c:506</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-012</span></td>
<td>EnableC2 string value</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_enable_c2_string</code></td>
<td><span class="file-ref">test_mqtt_parser.c:517</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-013</span></td>
<td>RequiredEVCCID set</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_required_evccid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:547</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-015</span></td>
<td>PrioStrategy set to MODBUS_ADDR (0) via MQTT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/PrioStrategy with payload &quot;0&quot;</li><li class="step-then"><span class="step-keyword">Then</span> Command type is MQTT_CMD_PRIO_STRATEGY with value 0</li></ul></td>
<td><code>test_prio_strategy_modbus_addr</code></td>
<td><span class="file-ref">test_mqtt_parser.c:570</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-015</span></td>
<td>PrioStrategy set to FIRST_CONNECTED (1)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_first_connected</code></td>
<td><span class="file-ref">test_mqtt_parser.c:584</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-015</span></td>
<td>PrioStrategy set to LAST_CONNECTED (2)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_last_connected</code></td>
<td><span class="file-ref">test_mqtt_parser.c:594</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-016</span></td>
<td>RotationInterval set to 0 (disabled) via MQTT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/RotationInterval with payload &quot;0&quot;</li><li class="step-then"><span class="step-keyword">Then</span> Command type is MQTT_CMD_ROTATION_INTERVAL with value 0</li></ul></td>
<td><code>test_rotation_interval_zero</code></td>
<td><span class="file-ref">test_mqtt_parser.c:627</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-016</span></td>
<td>RotationInterval set to minimum (30 minutes)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_min</code></td>
<td><span class="file-ref">test_mqtt_parser.c:641</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-016</span></td>
<td>RotationInterval set to maximum (1440 minutes = 24h)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_max</code></td>
<td><span class="file-ref">test_mqtt_parser.c:651</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-017</span></td>
<td>IdleTimeout set to minimum (30 seconds) via MQTT</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/IdleTimeout with payload &quot;30&quot;</li><li class="step-then"><span class="step-keyword">Then</span> Command type is MQTT_CMD_IDLE_TIMEOUT with value 30</li></ul></td>
<td><code>test_idle_timeout_min</code></td>
<td><span class="file-ref">test_mqtt_parser.c:684</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-017</span></td>
<td>IdleTimeout set to default (60 seconds)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_default</code></td>
<td><span class="file-ref">test_mqtt_parser.c:698</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-017</span></td>
<td>IdleTimeout set to maximum (300 seconds)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_max</code></td>
<td><span class="file-ref">test_mqtt_parser.c:708</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">MQTT Input Validation (29 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MQTT-002</span></td>
<td>Invalid mode string is rejected</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/Mode with payload &quot;Invalid&quot;</li><li class="step-then"><span class="step-keyword">Then</span> The parser returns false</li></ul></td>
<td><code>test_mode_invalid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:76</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-004</span></td>
<td>Current override with valid value</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/CurrentOverride with payload &quot;100&quot;</li><li class="step-then"><span class="step-keyword">Then</span> Command has current_override = 100</li></ul></td>
<td><code>test_current_override_valid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:114</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-004</span></td>
<td>Current override zero resets override</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_override_zero</code></td>
<td><span class="file-ref">test_mqtt_parser.c:128</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-004</span></td>
<td>Current override with max value</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_current_override_max</code></td>
<td><span class="file-ref">test_mqtt_parser.c:139</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-005</span></td>
<td>Max sum mains valid value</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_valid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:151</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-005</span></td>
<td>Max sum mains zero disables</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_zero</code></td>
<td><span class="file-ref">test_mqtt_parser.c:162</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-005</span></td>
<td>Max sum mains below minimum rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_below_min</code></td>
<td><span class="file-ref">test_mqtt_parser.c:172</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-005</span></td>
<td>Max sum mains above maximum rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_max_sum_mains_above_max</code></td>
<td><span class="file-ref">test_mqtt_parser.c:181</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-006</span></td>
<td>CP PWM override out of range rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cp_pwm_out_of_range</code></td>
<td><span class="file-ref">test_mqtt_parser.c:223</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-006</span></td>
<td>CP PWM override below -1 rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_cp_pwm_below_neg1</code></td>
<td><span class="file-ref">test_mqtt_parser.c:232</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-007</span></td>
<td>Mains meter out of range rejected (&gt;=2000)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mains_meter_out_of_range</code></td>
<td><span class="file-ref">test_mqtt_parser.c:272</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-007</span></td>
<td>Mains meter out of range rejected (&lt;=-2000)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mains_meter_out_of_range_neg</code></td>
<td><span class="file-ref">test_mqtt_parser.c:282</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-007</span></td>
<td>Mains meter missing fields rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mains_meter_missing_fields</code></td>
<td><span class="file-ref">test_mqtt_parser.c:292</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-008</span></td>
<td>EV meter partial data rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_ev_meter_partial</code></td>
<td><span class="file-ref">test_mqtt_parser.c:345</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>RGB color out of range rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rgb_out_of_range</code></td>
<td><span class="file-ref">test_mqtt_parser.c:406</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>RGB color negative rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rgb_negative</code></td>
<td><span class="file-ref">test_mqtt_parser.c:416</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>RGB color missing component rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rgb_missing</code></td>
<td><span class="file-ref">test_mqtt_parser.c:426</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-012</span></td>
<td>EnableC2 out of range rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_enable_c2_out_of_range</code></td>
<td><span class="file-ref">test_mqtt_parser.c:527</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-012</span></td>
<td>EnableC2 invalid string rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_enable_c2_invalid_string</code></td>
<td><span class="file-ref">test_mqtt_parser.c:536</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-013</span></td>
<td>RequiredEVCCID too long rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_required_evccid_too_long</code></td>
<td><span class="file-ref">test_mqtt_parser.c:558</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-015</span></td>
<td>PrioStrategy value 3 is rejected (out of range)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/PrioStrategy with payload &quot;3&quot;</li><li class="step-then"><span class="step-keyword">Then</span> The parser returns false</li></ul></td>
<td><code>test_prio_strategy_out_of_range</code></td>
<td><span class="file-ref">test_mqtt_parser.c:604</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-015</span></td>
<td>PrioStrategy negative value is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_prio_strategy_negative</code></td>
<td><span class="file-ref">test_mqtt_parser.c:616</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-016</span></td>
<td>RotationInterval in gap (1-29) is rejected</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/RotationInterval with payload &quot;15&quot;</li><li class="step-then"><span class="step-keyword">Then</span> The parser returns false</li></ul></td>
<td><code>test_rotation_interval_gap</code></td>
<td><span class="file-ref">test_mqtt_parser.c:661</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-016</span></td>
<td>RotationInterval above maximum is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rotation_interval_too_high</code></td>
<td><span class="file-ref">test_mqtt_parser.c:673</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-017</span></td>
<td>IdleTimeout below minimum (29) is rejected</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid MQTT prefix</li><li class="step-when"><span class="step-keyword">When</span> Topic is prefix/Set/IdleTimeout with payload &quot;29&quot;</li><li class="step-then"><span class="step-keyword">Then</span> The parser returns false</li></ul></td>
<td><code>test_idle_timeout_too_low</code></td>
<td><span class="file-ref">test_mqtt_parser.c:718</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-017</span></td>
<td>IdleTimeout above maximum (301) is rejected</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_too_high</code></td>
<td><span class="file-ref">test_mqtt_parser.c:730</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-017</span></td>
<td>IdleTimeout zero is rejected (minimum is 30)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_idle_timeout_zero</code></td>
<td><span class="file-ref">test_mqtt_parser.c:739</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-014</span></td>
<td>Unrecognized topic returns false</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_unrecognized_topic</code></td>
<td><span class="file-ref">test_mqtt_parser.c:750</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-014</span></td>
<td>Wrong prefix returns false</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_wrong_prefix</code></td>
<td><span class="file-ref">test_mqtt_parser.c:759</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">MQTT Meter Parsing (6 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MQTT-007</span></td>
<td>Mains meter format L1:L2:L3 is parsed correctly</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Valid three-phase mains meter data</li><li class="step-when"><span class="step-keyword">When</span> Payload is &quot;100:200:300&quot;</li><li class="step-then"><span class="step-keyword">Then</span> L1=100, L2=200, L3=300</li></ul></td>
<td><code>test_mains_meter_valid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:243</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-007</span></td>
<td>Mains meter with negative values</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mains_meter_negative</code></td>
<td><span class="file-ref">test_mqtt_parser.c:259</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-007</span></td>
<td>Mains meter via full command parse</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_mains_meter_command</code></td>
<td><span class="file-ref">test_mqtt_parser.c:302</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-008</span></td>
<td>EV meter format L1:L2:L3:W:WH is parsed correctly</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_ev_meter_valid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:317</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-008</span></td>
<td>EV meter with unknown values (-1)</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_ev_meter_unknown_values</code></td>
<td><span class="file-ref">test_mqtt_parser.c:332</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-008</span></td>
<td>EV meter via full command parse</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_ev_meter_command</code></td>
<td><span class="file-ref">test_mqtt_parser.c:355</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">MQTT Color Parsing (4 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>Valid RGB color parsed</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_rgb_valid</code></td>
<td><span class="file-ref">test_mqtt_parser.c:393</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>ColorOff topic parsed correctly</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_off_command</code></td>
<td><span class="file-ref">test_mqtt_parser.c:436</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>ColorSolar topic parsed correctly</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_solar_command</code></td>
<td><span class="file-ref">test_mqtt_parser.c:450</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MQTT-010</span></td>
<td>ColorCustom topic parsed correctly</td>
<td><ul class="scenario-steps"></ul></td>
<td><code>test_color_custom_command</code></td>
<td><span class="file-ref">test_mqtt_parser.c:461</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Multi-Node Load Balancing (14 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MULTI-001</span></td>
<td>Four EVSEs receive equal current distribution</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 4 EVSEs all in STATE_C, MaxCircuit=64A, no EV meter baseload</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> Each EVSE receives 160 deciamps (640 / 4 = 160) with all values equal</li></ul></td>
<td><code>test_four_evse_fair_distribution</code></td>
<td><span class="file-ref">test_multi_node.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-002</span></td>
<td>Master EVSE BalancedMax is derived from ChargeCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 4 EVSEs all in STATE_C, master ChargeCurrent limited to 200 deciamps (20A)</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> Master EVSE (Balanced[0]) does not exceed its ChargeCurrent limit of 200 deciamps</li></ul></td>
<td><code>test_four_evse_master_max_from_chargecurrent</code></td>
<td><span class="file-ref">test_multi_node.c:74</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-003</span></td>
<td>One EVSE with low max capacity, remainder shared by others</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, node 1 limited to BalancedMax=60 deciamps (6A)</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> Node 1 receives at most 60 deciamps while nodes 0 and 2 share the remainder equally</li></ul></td>
<td><code>test_one_evse_low_max_others_share</code></td>
<td><span class="file-ref">test_multi_node.c:102</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-004</span></td>
<td>Node going offline causes redistribution to remaining active nodes</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C receiving equal distribution</li><li class="step-when"><span class="step-keyword">When</span> Node 2 goes offline (BalancedState changes to STATE_A) and current is recalculated</li><li class="step-then"><span class="step-keyword">Then</span> Remaining active nodes each receive more current than before and offline node gets 0</li></ul></td>
<td><code>test_node_goes_offline_redistributes</code></td>
<td><span class="file-ref">test_multi_node.c:130</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-005</span></td>
<td>Priority scheduling allocates available power to highest-priority EVSE during shortage</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 4 EVSEs in STATE_C in Smart mode, available power ~105 dA (enough for 1 EVSE, not 4)</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with insufficient power for all nodes</li><li class="step-then"><span class="step-keyword">Then</span> Highest-priority EVSE gets all available power, others are paused</li></ul></td>
<td><code>test_all_nodes_mincurrent_during_shortage</code></td>
<td><span class="file-ref">test_multi_node.c:159</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-006</span></td>
<td>MaxCircuit limits total current distribution across all nodes</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 4 EVSEs in STATE_C in Normal mode with MaxCircuit=24A</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> Total distributed current across all nodes does not exceed 240 deciamps (MaxCircuit * 10)</li></ul></td>
<td><code>test_maxcircuit_limits_total_distribution</code></td>
<td><span class="file-ref">test_multi_node.c:189</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-007</span></td>
<td>MaxCircuit accounts for EV meter baseload in distribution</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in STATE_C, MaxCircuit=20A, EV meter measuring 250 deciamps total</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with EV meter baseload subtracted</li><li class="step-then"><span class="step-keyword">Then</span> Total distributed current does not exceed (MaxCircuit * 10) minus baseload</li></ul></td>
<td><code>test_maxcircuit_with_ev_meter_baseload</code></td>
<td><span class="file-ref">test_multi_node.c:217</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-008</span></td>
<td>Six EVSEs in large cluster receive fair distribution</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 6 EVSEs all in STATE_C, MaxCircuit=64A</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> All 6 EVSEs receive equal current within 1 deciamp tolerance (integer division rounding)</li></ul></td>
<td><code>test_six_evse_fair_distribution</code></td>
<td><span class="file-ref">test_multi_node.c:243</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-009</span></td>
<td>NoCurrent counter increments during hard power shortage</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 4 EVSEs in Smart mode, 50A mains measured against 25A limit, IsetBalanced too low</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated and total MinCurrent demand exceeds available power</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent counter increments above 0 indicating sustained shortage</li></ul></td>
<td><code>test_nocurrent_increments_on_hard_shortage</code></td>
<td><span class="file-ref">test_multi_node.c:269</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-010</span></td>
<td>NoCurrent counter clears when sufficient power is available</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in Smart mode, low mains load, IsetBalanced=400, NoCurrent previously at 5</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with plenty of available power</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent counter is cleared to 0</li></ul></td>
<td><code>test_nocurrent_zero_when_sufficient</code></td>
<td><span class="file-ref">test_multi_node.c:294</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-011</span></td>
<td>Node in STATE_B does not participate in current distribution</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs, nodes 0 and 2 in STATE_C, node 1 in STATE_B (waiting)</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> Only active STATE_C nodes (0 and 2) receive distributed current, each getting 320 deciamps</li></ul></td>
<td><code>test_state_b_node_gets_no_current</code></td>
<td><span class="file-ref">test_multi_node.c:319</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-012</span></td>
<td>IsetBalanced is capped at the sum of all active node maximums</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in STATE_C, node 1 limited to BalancedMax=80 deciamps (8A)</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with IsetBalanced exceeding ActiveMax (320+80=400)</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced is capped to 400, node 0 gets 320 and node 1 gets 80</li></ul></td>
<td><code>test_isetbalanced_capped_at_active_max</code></td>
<td><span class="file-ref">test_multi_node.c:344</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-013</span></td>
<td>Three EVSEs with all different BalancedMax values</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs: max 320, 160, 80 deciamps, MaxCircuit=64A</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> Each EVSE capped at its max, remainder redistributed to uncapped EVSEs</li></ul></td>
<td><code>test_three_evse_all_different_max</code></td>
<td><span class="file-ref">test_multi_node.c:369</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MULTI-014</span></td>
<td>Tight circuit with unequal max: surplus from small EVSE redistributed</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 2 EVSEs: EVSE[0] max 320, EVSE[1] max 60 (MinCurrent), MaxCircuit=25A</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[1] gets 60, EVSE[0] gets remainder (250-60=190)</li></ul></td>
<td><code>test_unequal_max_tight_circuit</code></td>
<td><span class="file-ref">test_multi_node.c:400</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">OCPP Current Limiting (12 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-OCPP-001</span></td>
<td>OCPP current limit exactly at MinCurrent boundary is accepted</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppMode enabled and MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to 6.0A (exactly MinCurrent) and balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 60 deciamps (6A) because the limit equals MinCurrent</li></ul></td>
<td><code>test_ocpp_limit_equal_to_mincurrent</code></td>
<td><span class="file-ref">test_ocpp.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-002</span></td>
<td>OCPP current limit exactly at MaxCurrent does not reduce current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppMode enabled and MaxCurrent=16A</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to 16.0A (exactly MaxCurrent) and balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent remains at 160 deciamps (16A) because OCPP limit does not cap below MaxCurrent</li></ul></td>
<td><code>test_ocpp_limit_equal_to_maxcurrent</code></td>
<td><span class="file-ref">test_ocpp.c:60</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-003</span></td>
<td>OCPP current limit above MaxCurrent does not increase current beyond MaxCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppMode enabled and MaxCurrent=16A</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to 32.0A (well above MaxCurrent) and balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent stays at 160 deciamps (MaxCurrent) because OCPP cannot raise current above hardware limit</li></ul></td>
<td><code>test_ocpp_limit_above_maxcurrent_no_increase</code></td>
<td><span class="file-ref">test_ocpp.c:78</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-004</span></td>
<td>OCPP current limit is ignored when LoadBl is set to master</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a master (LoadBl=1) in STATE_C with OcppMode enabled</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to 3.0A (below MinCurrent) and balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent remains at 160 deciamps because OCPP limit requires standalone mode (LoadBl=0)</li></ul></td>
<td><code>test_ocpp_ignored_when_loadbl_master</code></td>
<td><span class="file-ref">test_ocpp.c:96</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-005</span></td>
<td>OCPP current limit is ignored when LoadBl is set to node</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a node (LoadBl=2) in STATE_C with OcppMode enabled</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to 3.0A (below MinCurrent) and balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent remains at 160 deciamps because OCPP limit requires standalone mode (LoadBl=0)</li></ul></td>
<td><code>test_ocpp_ignored_when_loadbl_node</code></td>
<td><span class="file-ref">test_ocpp.c:115</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-006</span></td>
<td>OverrideCurrent takes precedence over OCPP limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppCurrentLimit=10.0A and OverrideCurrent=80 deciamps</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 80 deciamps because OverrideCurrent is applied after OCPP capping</li></ul></td>
<td><code>test_override_current_overrides_ocpp</code></td>
<td><span class="file-ref">test_ocpp.c:134</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-007</span></td>
<td>OverrideCurrent restores charging even when OCPP would zero the current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppCurrentLimit=3.0A (below MinCurrent) and OverrideCurrent=120</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 120 deciamps because OverrideCurrent overrides the OCPP-zeroed value</li></ul></td>
<td><code>test_override_current_overrides_ocpp_zero</code></td>
<td><span class="file-ref">test_ocpp.c:151</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-008</span></td>
<td>OCPP current limit of 0.0A zeros the charge current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppMode enabled</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to 0.0A and balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is zeroed because 0.0A is below MinCurrent (6A)</li></ul></td>
<td><code>test_ocpp_limit_zero_zeros_current</code></td>
<td><span class="file-ref">test_ocpp.c:170</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-009</span></td>
<td>Negative OCPP current limit is treated as no limit set</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C with OcppMode enabled</li><li class="step-when"><span class="step-keyword">When</span> OcppCurrentLimit is set to -1.0A (default init value meaning no limit)</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent remains at 160 deciamps because the OCPP capping block is skipped</li></ul></td>
<td><code>test_ocpp_negative_limit_no_restriction</code></td>
<td><span class="file-ref">test_ocpp.c:188</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-010</span></td>
<td>OCPP limit of 0.0A blocks current availability check</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone with OcppMode enabled and OcppCurrentLimit=0.0A</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because OCPP limit is below MinCurrent</li></ul></td>
<td><code>test_ocpp_blocks_current_available_at_zero</code></td>
<td><span class="file-ref">test_ocpp.c:206</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-011</span></td>
<td>OCPP limit at MinCurrent allows current availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone with OcppMode enabled and OcppCurrentLimit=6.0A (MinCurrent)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because 6.0A is not less than MinCurrent</li></ul></td>
<td><code>test_ocpp_allows_current_available_at_mincurrent</code></td>
<td><span class="file-ref">test_ocpp.c:223</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-OCPP-012</span></td>
<td>Negative OCPP limit does not block current availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone with OcppMode enabled and OcppCurrentLimit=-1.0A (no limit)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because negative limit skips the OCPP availability check</li></ul></td>
<td><code>test_ocpp_negative_limit_allows_current_available</code></td>
<td><span class="file-ref">test_ocpp.c:241</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Operating Modes (21 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-MODE-001</span></td>
<td>Normal mode sets IsetBalanced to MaxCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Normal mode</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced equals MaxCurrent * 10 (fixed current allocation)</li></ul></td>
<td><code>test_normal_mode_uses_max_current</code></td>
<td><span class="file-ref">test_operating_modes.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-002</span></td>
<td>Normal mode ignores mains meter readings</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Normal mode with high MainsMeterImeasured=300</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced remains at MaxCurrent * 10 regardless of mains load</li></ul></td>
<td><code>test_normal_mode_ignores_mains</code></td>
<td><span class="file-ref">test_operating_modes.c:45</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-003</span></td>
<td>Normal mode respects MaxCapacity as upper bound</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Normal mode with MaxCapacity=10A and MaxCurrent=16A</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is limited to 100 deciamps (MaxCapacity * 10) instead of MaxCurrent</li></ul></td>
<td><code>test_normal_mode_respects_max_capacity</code></td>
<td><span class="file-ref">test_operating_modes.c:62</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-004</span></td>
<td>Smart mode limits current based on MaxMains minus baseload</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Smart mode with MaxMains=25A and MainsMeterImeasured=200</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced does not exceed (MaxMains * 10) minus baseload</li></ul></td>
<td><code>test_smart_mode_respects_maxmains</code></td>
<td><span class="file-ref">test_operating_modes.c:81</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-005</span></td>
<td>Smart mode increases current conservatively (Idifference/4)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Smart mode with low mains usage and measurements updated</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with headroom available</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced increases from its initial value but conservatively (not full step)</li></ul></td>
<td><code>test_smart_mode_slow_increase</code></td>
<td><span class="file-ref">test_operating_modes.c:101</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-006</span></td>
<td>Smart mode decreases current rapidly when over mains limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Smart mode with IsetBalanced=200 and mains way over MaxMains=10A</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with negative Idifference</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced decreases rapidly (full Idifference, not divided) below the initial 200</li></ul></td>
<td><code>test_smart_mode_fast_decrease</code></td>
<td><span class="file-ref">test_operating_modes.c:123</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-007</span></td>
<td>Solar mode requires surplus power to make current available</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with StartCurrent=6A and Isum=0 (no surplus)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because there is no solar surplus for charging</li></ul></td>
<td><code>test_solar_current_available_requires_surplus</code></td>
<td><span class="file-ref">test_operating_modes.c:146</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-008</span></td>
<td>Solar mode allows charging when sufficient surplus is available</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with StartCurrent=6A and Isum=-80 (8A export surplus)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because export surplus exceeds StartCurrent threshold</li></ul></td>
<td><code>test_solar_current_available_with_surplus</code></td>
<td><span class="file-ref">test_operating_modes.c:165</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-009</span></td>
<td>Solar mode increases current in small steps when surplus is available</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Solar mode with 2A export surplus and past solar startup phase</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced increases from its initial 100 value in fine-grained solar increments</li></ul></td>
<td><code>test_solar_fine_grained_increase</code></td>
<td><span class="file-ref">test_operating_modes.c:185</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-010</span></td>
<td>Solar mode decreases current rapidly when importing from grid</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in STATE_C in Solar mode with Isum=50 (5A import) and IsetBalanced=100</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with grid import detected</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced decreases below 100 to reduce grid import quickly</li></ul></td>
<td><code>test_solar_rapid_decrease_on_import</code></td>
<td><span class="file-ref">test_operating_modes.c:209</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-011</span></td>
<td>Solar mode ImportCurrent offset allows controlled grid import</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with ImportCurrent=3A allowance and Isum=20 (2A import within allowance)</li><li class="step-when"><span class="step-keyword">When</span> Balanced current is calculated with import within the allowed offset</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced increases because IsumImport (20 - 30 = -10) indicates effective surplus</li></ul></td>
<td><code>test_solar_import_current_offset</code></td>
<td><span class="file-ref">test_operating_modes.c:233</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-012</span></td>
<td>EnableC2=NOT_PRESENT does not force single phase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to NOT_PRESENT (contactor 2 not installed)</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 because the phase switching hardware is not present</li></ul></td>
<td><code>test_force_single_phase_not_present</code></td>
<td><span class="file-ref">test_operating_modes.c:259</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-013</span></td>
<td>EnableC2=ALWAYS_OFF forces single phase operation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to ALWAYS_OFF (contactor 2 always disabled)</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 because the EVSE is configured to always operate in single phase</li></ul></td>
<td><code>test_force_single_phase_always_off</code></td>
<td><span class="file-ref">test_operating_modes.c:273</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-014</span></td>
<td>EnableC2=SOLAR_OFF forces single phase when in Solar mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to SOLAR_OFF and Mode is MODE_SOLAR</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 because SOLAR_OFF disables contactor 2 in solar mode</li></ul></td>
<td><code>test_force_single_phase_solar_off_in_solar_mode</code></td>
<td><span class="file-ref">test_operating_modes.c:287</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-015</span></td>
<td>EnableC2=SOLAR_OFF does not force single phase in Smart mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to SOLAR_OFF and Mode is MODE_SMART</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 because SOLAR_OFF only applies in Solar mode, not Smart mode</li></ul></td>
<td><code>test_force_single_phase_solar_off_in_smart_mode</code></td>
<td><span class="file-ref">test_operating_modes.c:302</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-016</span></td>
<td>EnableC2=AUTO forces single phase when charging on 1 phase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to AUTO and Nr_Of_Phases_Charging=1</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 because AUTO mode follows the current phase count</li></ul></td>
<td><code>test_force_single_phase_auto_c2_1p</code></td>
<td><span class="file-ref">test_operating_modes.c:317</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-017</span></td>
<td>EnableC2=AUTO does not force single phase when charging on 3 phases</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to AUTO and Nr_Of_Phases_Charging=3</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 because AUTO mode allows 3-phase operation when already on 3 phases</li></ul></td>
<td><code>test_force_single_phase_auto_c2_3p</code></td>
<td><span class="file-ref">test_operating_modes.c:332</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-018</span></td>
<td>EnableC2=ALWAYS_ON does not force single phase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to ALWAYS_ON (contactor 2 always enabled for 3-phase)</li><li class="step-when"><span class="step-keyword">When</span> evse_force_single_phase is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 because the EVSE is configured to always operate in three phase</li></ul></td>
<td><code>test_force_single_phase_always_on</code></td>
<td><span class="file-ref">test_operating_modes.c:347</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-019</span></td>
<td>STATE_C entry with single phase disables contactor 2</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to ALWAYS_OFF (force single phase)</li><li class="step-when"><span class="step-keyword">When</span> EVSE transitions to STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> Contactor 1 is on, contactor 2 is off, and Nr_Of_Phases_Charging is 1</li></ul></td>
<td><code>test_state_C_contactor2_off_when_single_phase</code></td>
<td><span class="file-ref">test_operating_modes.c:361</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-020</span></td>
<td>STATE_C entry with three phase enables both contactors</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has EnableC2 set to NOT_PRESENT (default 3-phase behavior)</li><li class="step-when"><span class="step-keyword">When</span> EVSE transitions to STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> Both contactor 1 and contactor 2 are on and Nr_Of_Phases_Charging is 3</li></ul></td>
<td><code>test_state_C_contactor2_on_when_three_phase</code></td>
<td><span class="file-ref">test_operating_modes.c:378</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-MODE-021</span></td>
<td>Phase switch from 3P to 1P completes on STATE_C entry</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has Switching_Phases_C2=GOING_TO_SWITCH_1P and EnableC2=AUTO</li><li class="step-when"><span class="step-keyword">When</span> EVSE transitions to STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> Nr_Of_Phases_Charging is set to 1 and Switching_Phases_C2 is cleared to NO_SWITCH</li></ul></td>
<td><code>test_phase_switch_going_to_1p</code></td>
<td><span class="file-ref">test_operating_modes.c:395</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Phase Switching (12 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-PHASE-003</span></td>
<td>AUTO + SOLAR: no switch needed when already at correct phase count</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=AUTO, MODE_SOLAR, and various phase counts</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is NO_SWITCH when already at the correct phase count</li></ul></td>
<td><code>test_check_auto_solar_forces_1p</code></td>
<td><span class="file-ref">test_phase_switching.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-004</span></td>
<td>AUTO + SOLAR already on 1 phase results in NO_SWITCH</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=AUTO, MODE_SOLAR, and 1 phase</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is NO_SWITCH (already single phase)</li></ul></td>
<td><code>test_check_auto_solar_already_1p</code></td>
<td><span class="file-ref">test_phase_switching.c:52</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-005</span></td>
<td>AUTO + SMART forces 3-phase when currently on 1 phase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=AUTO, MODE_SMART, and 1 phase</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_check_auto_smart_forces_3p</code></td>
<td><span class="file-ref">test_phase_switching.c:73</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-006</span></td>
<td>AUTO + SMART already on 3 phases results in NO_SWITCH</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=AUTO, MODE_SMART, and 3 phases</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is NO_SWITCH (already three phase)</li></ul></td>
<td><code>test_check_auto_smart_already_3p</code></td>
<td><span class="file-ref">test_phase_switching.c:94</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-007</span></td>
<td>ALWAYS_OFF in STATE_A sets Nr_Of_Phases_Charging directly to 1</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with EnableC2=ALWAYS_OFF and 3 phases configured</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Nr_Of_Phases_Charging is set directly to 1 (no deferred switch needed)</li></ul></td>
<td><code>test_check_always_off_in_state_a</code></td>
<td><span class="file-ref">test_phase_switching.c:115</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-008</span></td>
<td>ALWAYS_OFF in STATE_B sets deferred switching flag to 1P</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=ALWAYS_OFF and 3 phases configured</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_1P (deferred until STATE_C entry)</li></ul></td>
<td><code>test_check_always_off_in_state_b</code></td>
<td><span class="file-ref">test_phase_switching.c:136</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-009</span></td>
<td>SOLAR_OFF + SMART forces 3-phase charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=SOLAR_OFF, MODE_SMART, and 1 phase</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_check_solar_off_smart_3p</code></td>
<td><span class="file-ref">test_phase_switching.c:156</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-010</span></td>
<td>SOLAR_OFF + SOLAR forces 1-phase charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=SOLAR_OFF, MODE_SOLAR, and 3 phases</li><li class="step-when"><span class="step-keyword">When</span> evse_check_switching_phases is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_1P</li></ul></td>
<td><code>test_check_solar_off_solar_1p</code></td>
<td><span class="file-ref">test_phase_switching.c:178</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-011</span></td>
<td>STATE_C entry applies deferred 1P switch and opens contactor 2</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Switching_Phases_C2 is GOING_TO_SWITCH_1P with EnableC2=ALWAYS_OFF</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> Nr_Of_Phases_Charging is 1 and contactor2 is off (open)</li></ul></td>
<td><code>test_state_c_applies_1p_switch</code></td>
<td><span class="file-ref">test_phase_switching.c:199</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-012</span></td>
<td>STATE_C entry applies deferred 3P switch and closes contactor 2</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Switching_Phases_C2 is GOING_TO_SWITCH_3P with EnableC2=ALWAYS_ON</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> Nr_Of_Phases_Charging is 3 and contactor2 is on (closed)</li></ul></td>
<td><code>test_state_c_applies_3p_switch</code></td>
<td><span class="file-ref">test_phase_switching.c:220</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-013</span></td>
<td>STATE_C entry resets Switching_Phases_C2 to NO_SWITCH</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Switching_Phases_C2 is GOING_TO_SWITCH_1P</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is reset to NO_SWITCH</li></ul></td>
<td><code>test_state_c_resets_switching</code></td>
<td><span class="file-ref">test_phase_switching.c:241</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-014</span></td>
<td>Full 3P to 1P to 3P phase switching cycle in solar mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging on 3 phases with EnableC2=AUTO</li><li class="step-when"><span class="step-keyword">When</span> Solar shortage triggers 3P-&gt;1P switch, then surplus triggers 1P-&gt;3P switch</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE correctly switches from 3P to 1P and back to 3P with proper contactor and flag states</li></ul></td>
<td><code>test_full_3p_1p_3p_cycle</code></td>
<td><span class="file-ref">test_phase_switching.c:259</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Power Availability (22 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-PWR-001</span></td>
<td>Normal mode always reports current as available regardless of mains load</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in Normal mode with very high MainsMeterImeasured=999</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because Normal mode does not check mains</li></ul></td>
<td><code>test_normal_mode_always_available</code></td>
<td><span class="file-ref">test_power_availability.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-002</span></td>
<td>Normal mode available even with high mains load</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in Normal mode with MainsMeterImeasured=400</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because Normal mode ignores mains measurements</li></ul></td>
<td><code>test_normal_mode_available_with_high_load</code></td>
<td><span class="file-ref">test_power_availability.c:45</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-003</span></td>
<td>Smart mode allows current when mains load plus MinCurrent is under MaxMains</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in Smart mode with MaxMains=25A and MainsMeterImeasured=100 (10A)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because baseload (10A) + MinCurrent (6A) = 16A &lt; MaxMains (25A)</li></ul></td>
<td><code>test_smart_maxmains_allows_under_limit</code></td>
<td><span class="file-ref">test_power_availability.c:62</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-004</span></td>
<td>Smart mode blocks current when mains load plus MinCurrent exceeds MaxMains</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone in Smart mode with MaxMains=10A and MainsMeterImeasured=200 (20A baseload)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because baseload (20A) + MinCurrent (6A) = 26A &gt; MaxMains (10A)</li></ul></td>
<td><code>test_smart_maxmains_blocks_over_limit</code></td>
<td><span class="file-ref">test_power_availability.c:80</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-005</span></td>
<td>Smart mode allows current when circuit load is under MaxCircuit limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is master (LoadBl=1) in Smart mode with MaxCircuit=20A and EVMeterImeasured=50</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because circuit load (5A) + MinCurrent (6A) is under MaxCircuit</li></ul></td>
<td><code>test_smart_maxcircuit_allows_under_limit</code></td>
<td><span class="file-ref">test_power_availability.c:101</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-006</span></td>
<td>Smart mode blocks current when circuit load exceeds MaxCircuit limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is master (LoadBl=1) in Smart mode with MaxCircuit=8A and EVMeterImeasured=100 (10A)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because circuit load (10A) already exceeds MaxCircuit (8A)</li></ul></td>
<td><code>test_smart_maxcircuit_blocks_over_limit</code></td>
<td><span class="file-ref">test_power_availability.c:121</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-007</span></td>
<td>MaxSumMains allows current when sum of phase currents is under limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode with MaxSumMains=50 and Isum=100 (10A total)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because Isum plus MinCurrent is under MaxSumMains limit</li></ul></td>
<td><code>test_maxsummains_allows_under_limit</code></td>
<td><span class="file-ref">test_power_availability.c:143</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-008</span></td>
<td>MaxSumMains blocks current when sum of phase currents exceeds limit</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode with MaxSumMains=10 and Isum=200 (way over limit)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because total phase current sum exceeds MaxSumMains</li></ul></td>
<td><code>test_maxsummains_blocks_over_limit</code></td>
<td><span class="file-ref">test_power_availability.c:162</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-009</span></td>
<td>MaxSumMains=0 disables the sum-of-mains check entirely</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode with MaxSumMains=0 (disabled) and Isum=9999 (extremely high)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because MaxSumMains=0 means the check is skipped</li></ul></td>
<td><code>test_maxsummains_zero_disables_check</code></td>
<td><span class="file-ref">test_power_availability.c:182</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-010</span></td>
<td>Solar mode blocks current when no surplus is available</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with StartCurrent=6A and Isum=0 (no export)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because there is no solar surplus for charging</li></ul></td>
<td><code>test_solar_no_surplus_blocks</code></td>
<td><span class="file-ref">test_power_availability.c:203</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-011</span></td>
<td>Solar mode allows current when surplus exceeds StartCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with StartCurrent=6A and Isum=-80 (8A export surplus)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because 8A surplus exceeds 6A StartCurrent threshold</li></ul></td>
<td><code>test_solar_surplus_allows</code></td>
<td><span class="file-ref">test_power_availability.c:220</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-012</span></td>
<td>Solar mode blocks current when surplus is below StartCurrent threshold</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with StartCurrent=10A and Isum=-80 (only 8A surplus)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because 8A surplus is below the 10A StartCurrent threshold</li></ul></td>
<td><code>test_solar_insufficient_surplus_blocks</code></td>
<td><span class="file-ref">test_power_availability.c:237</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-013</span></td>
<td>Solar mode with active EVSE checks fair share before allowing more</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Solar mode with one active EVSE at MinCurrent and Isum=10 (1A import)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because grid import indicates insufficient surplus for another EVSE</li></ul></td>
<td><code>test_solar_with_active_evse_checks_fair_share</code></td>
<td><span class="file-ref">test_power_availability.c:254</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-014</span></td>
<td>OCPP limit below MinCurrent blocks power availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone with OcppMode enabled and OcppCurrentLimit=4.0A (below MinCurrent=6A)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (unavailable) because OCPP limit is below the minimum viable charge current</li></ul></td>
<td><code>test_ocpp_limit_blocks_when_below_min</code></td>
<td><span class="file-ref">test_power_availability.c:280</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-015</span></td>
<td>OCPP limit above MinCurrent allows power availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone with OcppMode enabled and OcppCurrentLimit=10.0A (above MinCurrent=6A)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because OCPP limit is above the minimum viable charge current</li></ul></td>
<td><code>test_ocpp_limit_allows_when_above_min</code></td>
<td><span class="file-ref">test_power_availability.c:297</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-016</span></td>
<td>OCPP negative limit (no limit set) allows power availability</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is standalone with OcppMode enabled and OcppCurrentLimit=-1.0A (no limit)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because negative OCPP limit means no restriction</li></ul></td>
<td><code>test_ocpp_no_limit_allows</code></td>
<td><span class="file-ref">test_power_availability.c:314</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-017</span></td>
<td>OCPP availability check is skipped for non-standalone configurations</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is master (LoadBl=1) with OcppMode enabled and OcppCurrentLimit=3.0A (below MinCurrent)</li><li class="step-when"><span class="step-keyword">When</span> evse_is_current_available is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1 (available) because OCPP check requires LoadBl=0 (standalone)</li></ul></td>
<td><code>test_ocpp_check_only_for_standalone</code></td>
<td><span class="file-ref">test_power_availability.c:330</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-018</span></td>
<td>PWM duty cycle conversion for 6A (minimum charge current)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A charge current of 60 deciamps (6A)</li><li class="step-when"><span class="step-keyword">When</span> evse_current_to_duty is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 102 as the PWM duty cycle value (60/0.6 * 1024/1000)</li></ul></td>
<td><code>test_current_to_duty_6A</code></td>
<td><span class="file-ref">test_power_availability.c:350</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-019</span></td>
<td>PWM duty cycle conversion for 16A (common residential limit)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A charge current of 160 deciamps (16A)</li><li class="step-when"><span class="step-keyword">When</span> evse_current_to_duty is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns a duty cycle value between 100 and 600 (low-range formula)</li></ul></td>
<td><code>test_current_to_duty_16A</code></td>
<td><span class="file-ref">test_power_availability.c:364</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-020</span></td>
<td>PWM duty cycle conversion for 51A (upper boundary of low-range formula)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A charge current of 510 deciamps (51A)</li><li class="step-when"><span class="step-keyword">When</span> evse_current_to_duty is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns a duty cycle value between 800 and 1000 (near top of low-range)</li></ul></td>
<td><code>test_current_to_duty_51A</code></td>
<td><span class="file-ref">test_power_availability.c:378</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-021</span></td>
<td>PWM duty cycle conversion for 60A (high-range formula)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A charge current of 600 deciamps (60A)</li><li class="step-when"><span class="step-keyword">When</span> evse_current_to_duty is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns a duty cycle value between 850 and 1000 (high-range formula: current/2.5 + 640)</li></ul></td>
<td><code>test_current_to_duty_high_range</code></td>
<td><span class="file-ref">test_power_availability.c:392</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PWR-022</span></td>
<td>PWM duty cycle conversion for 80A (near maximum charge current)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A charge current of 800 deciamps (80A)</li><li class="step-when"><span class="step-keyword">When</span> evse_current_to_duty is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns a duty cycle value between 950 and 1024 (near the top of the PWM range)</li></ul></td>
<td><code>test_current_to_duty_80A</code></td>
<td><span class="file-ref">test_power_availability.c:406</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Priority-Based Power Scheduling (29 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-LB-100</span></td>
<td>MODBUS_ADDR strategy produces ascending address order</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master (LoadBl=1) with 4 EVSEs in STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_sort_priority() is called</li><li class="step-then"><span class="step-keyword">Then</span> Priority[] = {0, 1, 2, 3}</li></ul></td>
<td><code>test_sort_modbus_addr</code></td>
<td><span class="file-ref">test_scheduling.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-101</span></td>
<td>FIRST_CONNECTED strategy orders by earliest connection time</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_sort_priority() is called</li><li class="step-then"><span class="step-keyword">Then</span> Priority[] = {1, 2, 0, ...} (EVSE[1] first, EVSE[0] last)</li></ul></td>
<td><code>test_sort_first_connected</code></td>
<td><span class="file-ref">test_scheduling.c:70</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-102</span></td>
<td>LAST_CONNECTED strategy orders by most recent connection time</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C</li><li class="step-when"><span class="step-keyword">When</span> evse_sort_priority() is called</li><li class="step-then"><span class="step-keyword">Then</span> Priority[] = {0, 2, 1, ...} (EVSE[0] first, EVSE[1] last)</li></ul></td>
<td><code>test_sort_last_connected</code></td>
<td><span class="file-ref">test_scheduling.c:94</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-103</span></td>
<td>Disconnected EVSEs are sorted to end regardless of strategy</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 4 EVSEs: [0]=STATE_C, [1]=STATE_A, [2]=STATE_C, [3]=STATE_A</li><li class="step-when"><span class="step-keyword">When</span> evse_sort_priority() is called</li><li class="step-then"><span class="step-keyword">Then</span> Priority[] = {0, 2, 1, 3} (active EVSEs first, then disconnected)</li></ul></td>
<td><code>test_sort_disconnected_to_end</code></td>
<td><span class="file-ref">test_scheduling.c:118</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-110</span></td>
<td>Insufficient power for 3 EVSEs: first 2 in priority get MinCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A, MaxCircuit=20A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[0] &gt;= 60 and Balanced[1] &gt;= 60 and Balanced[2] == 0</li></ul></td>
<td><code>test_shortage_first_two_get_current</code></td>
<td><span class="file-ref">test_scheduling.c:146</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-111</span></td>
<td>Power for only 1 EVSE: highest priority gets it all</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[0] == 80 and Balanced[1] == 0 and Balanced[2] == 0</li></ul></td>
<td><code>test_shortage_one_evse_gets_all</code></td>
<td><span class="file-ref">test_scheduling.c:177</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-112</span></td>
<td>Sufficient power: all EVSEs get current, no scheduling needed</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> All EVSEs get current, no LESS_6A errors, NoCurrent == 0</li></ul></td>
<td><code>test_sufficient_power_no_scheduling</code></td>
<td><span class="file-ref">test_scheduling.c:204</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-113</span></td>
<td>Surplus above MinCurrent distributed fairly among active EVSEs</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in STATE_C, MinCurrent=6A, BalancedMax={320,320}</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[0] == 100 and Balanced[1] == 100 (10A each = 6A + 4A surplus)</li></ul></td>
<td><code>test_surplus_distributed_fairly</code></td>
<td><span class="file-ref">test_scheduling.c:232</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-114</span></td>
<td>Standalone mode (LoadBl=0) does not use priority scheduling</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Single EVSE (LoadBl=0) in STATE_C, MinCurrent=6A, Mode=SMART</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent increments (original behavior preserved), no ScheduleState changes</li></ul></td>
<td><code>test_standalone_no_scheduling</code></td>
<td><span class="file-ref">test_scheduling.c:263</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-115</span></td>
<td>Solar mode: paused EVSEs get NO_SUN error instead of LESS_6A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in STATE_C, Mode=MODE_SOLAR</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[1] == 0 and BalancedError[1] has NO_SUN set</li></ul></td>
<td><code>test_solar_paused_gets_no_sun</code></td>
<td><span class="file-ref">test_scheduling.c:300</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-116</span></td>
<td>Capped EVSE surplus redistributed to uncapped ones</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[1] == 80 (capped) and Balanced[0] + Balanced[2] == 160</li></ul></td>
<td><code>test_capped_surplus_redistribution</code></td>
<td><span class="file-ref">test_scheduling.c:337</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-117</span></td>
<td>Power exactly equals MinCurrent for 1 EVSE</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Exactly 1 EVSE has Balanced &gt;= 60, exactly 2 have Balanced == 0</li></ul></td>
<td><code>test_exactly_one_mincurrent</code></td>
<td><span class="file-ref">test_scheduling.c:363</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-118</span></td>
<td>Zero available power pauses all EVSEs</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> All Balanced[] == 0, all paused, NoCurrent increments</li></ul></td>
<td><code>test_zero_power_pauses_all</code></td>
<td><span class="file-ref">test_scheduling.c:394</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-119</span></td>
<td>NoCurrent does NOT increment when priority scheduling pauses some EVSEs</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 3 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent == 0, EVSE[0] is charging</li></ul></td>
<td><code>test_no_current_not_incremented_on_deliberate_pause</code></td>
<td><span class="file-ref">test_scheduling.c:422</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-120</span></td>
<td>EVSE drawing &lt;1A when IdleTimer expires gets paused</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in STATE_C, EVSE[0] active, EVSE[1] paused</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] paused, EVSE[1] activated with IdleTimer[1] = 0</li></ul></td>
<td><code>test_idle_evse_paused_at_timeout</code></td>
<td><span class="file-ref">test_scheduling.c:450</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-121</span></td>
<td>EVSE not paused before IdleTimeout expires (anti-flap)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE[0] active with IdleTimer[0] = 30, IdleTimeout = 60</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] remains active</li></ul></td>
<td><code>test_antiflap_not_paused_early</code></td>
<td><span class="file-ref">test_scheduling.c:479</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-122</span></td>
<td>EVSE drawing power when IdleTimer expires stays active</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE[0] active with IdleTimer[0] = 59, IdleTimeout = 60</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] stays active, RotationTimer starts if RotationInterval &gt; 0</li></ul></td>
<td><code>test_charging_evse_stays_active</code></td>
<td><span class="file-ref">test_scheduling.c:505</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-123</span></td>
<td>Full idle cycle: all EVSEs tried, recircle to first</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs in STATE_C, EVSE[2] active (last tried), EVSE[0] and [1] paused</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[2] paused, EVSE[0] reactivated (wraps around)</li></ul></td>
<td><code>test_idle_cycle_wraps_around</code></td>
<td><span class="file-ref">test_scheduling.c:534</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-140</span></td>
<td>RotationTimer expiry pauses current EVSE and activates next</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs in STATE_C, EVSE[0] active, RotationInterval=30</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] paused, EVSE[1] activated, RotationTimer reset to 1800</li></ul></td>
<td><code>test_rotation_timer_expires</code></td>
<td><span class="file-ref">test_scheduling.c:567</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-141</span></td>
<td>RotationInterval=0 disables rotation entirely</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 2 EVSEs, EVSE[0] active, RotationInterval = 0</li><li class="step-when"><span class="step-keyword">When</span> Checking ScheduleState</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] still active (never rotated)</li></ul></td>
<td><code>test_rotation_disabled</code></td>
<td><span class="file-ref">test_scheduling.c:598</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-142</span></td>
<td>Rotation wraps from last priority to first</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs in priority order {0,1,2}, EVSE[2] active</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[2] paused, EVSE[0] activated</li></ul></td>
<td><code>test_rotation_wraps_to_first</code></td>
<td><span class="file-ref">test_scheduling.c:628</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-143</span></td>
<td>Rotation skips disconnected EVSEs (STATE_A)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs: [0] active, [1] STATE_A disconnected, [2] paused</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] paused, EVSE[2] activated (EVSE[1] skipped)</li></ul></td>
<td><code>test_rotation_skips_disconnected</code></td>
<td><span class="file-ref">test_scheduling.c:657</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-144</span></td>
<td>Newly activated EVSE gets idle check before rotation timer applies</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE[1] just activated via rotation, IdleTimeout=60, RotationInterval=30</li><li class="step-when"><span class="step-keyword">When</span> 60 seconds pass</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[1] paused due to idle (not waiting for rotation)</li></ul></td>
<td><code>test_idle_check_before_rotation</code></td>
<td><span class="file-ref">test_scheduling.c:687</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-150</span></td>
<td>Power increases: paused EVSE reactivated immediately</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs, EVSE[0] active, EVSE[1] and [2] paused</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called with new power</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[1] reactivated, IdleTimer reset</li></ul></td>
<td><code>test_power_increase_reactivates</code></td>
<td><span class="file-ref">test_scheduling.c:723</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-151</span></td>
<td>Reactivation follows priority order</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs paused, PrioStrategy=PRIO_MODBUS_ADDR</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] and EVSE[1] activated (not [0] and [2])</li></ul></td>
<td><code>test_reactivation_follows_priority</code></td>
<td><span class="file-ref">test_scheduling.c:758</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-160</span></td>
<td>Original bug: 2 EVSEs, power drops, only 1 stops (no oscillation)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 2 EVSEs in STATE_C, MinCurrent=6A, MaxCircuit=11A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> Exactly 1 EVSE continues, 1 paused, NoCurrent == 0</li></ul></td>
<td><code>test_regression_no_oscillation</code></td>
<td><span class="file-ref">test_scheduling.c:790</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-161</span></td>
<td>6 EVSEs, power for 5: lowest priority paused</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Master with 6 EVSEs in STATE_C, MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 0) is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSEs [0]-[4] receive current, EVSE[5] paused</li></ul></td>
<td><code>test_six_evse_lowest_paused</code></td>
<td><span class="file-ref">test_scheduling.c:820</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-162</span></td>
<td>Node goes offline: removed from scheduling</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 3 EVSEs, EVSE[1] goes offline (STATE_A)</li><li class="step-when"><span class="step-keyword">When</span> evse_schedule_tick_1s() runs</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[1] gets ScheduleState = SCHED_INACTIVE</li></ul></td>
<td><code>test_offline_node_removed</code></td>
<td><span class="file-ref">test_scheduling.c:845</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-LB-163</span></td>
<td>New EVSE join during shortage doesn&#x27;t displace active ones</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> 2 EVSEs charging, power for 2 at MinCurrent</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current(ctx, 1) is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE[0] and EVSE[1] keep allocation, EVSE[2] gets 0</li></ul></td>
<td><code>test_new_evse_doesnt_displace</code></td>
<td><span class="file-ref">test_scheduling.c:872</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Serial Message Parsing (9 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-SERIAL-001</span></td>
<td>Valid three-phase Irms message with address 011</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer containing &quot;Irms:011,312,123,124&quot;</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> Address is 11 and three phase currents are parsed correctly</li></ul></td>
<td><code>test_irms_valid_three_phase</code></td>
<td><span class="file-ref">test_serial_parser.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-001</span></td>
<td>Irms message with negative current values</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer with negative Irms values (solar injection)</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> Negative values are parsed correctly</li></ul></td>
<td><code>test_irms_negative_values</code></td>
<td><span class="file-ref">test_serial_parser.c:40</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-001</span></td>
<td>Irms message with zero values</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer with all zero Irms values</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> All values parsed as zero</li></ul></td>
<td><code>test_irms_zero_values</code></td>
<td><span class="file-ref">test_serial_parser.c:57</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-001</span></td>
<td>Irms message embedded in larger buffer with extra text</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer with text before and after the Irms token</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> The Irms message is found and parsed correctly</li></ul></td>
<td><code>test_irms_embedded_in_buffer</code></td>
<td><span class="file-ref">test_serial_parser.c:74</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-002</span></td>
<td>Valid power measurement with address 010</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer containing &quot;PowerMeasured:010,500&quot;</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_power is called</li><li class="step-then"><span class="step-keyword">Then</span> Address is 10 and power is 500</li></ul></td>
<td><code>test_power_valid</code></td>
<td><span class="file-ref">test_serial_parser.c:147</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-002</span></td>
<td>Power measurement with negative value (export)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer with negative power value</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_power is called</li><li class="step-then"><span class="step-keyword">Then</span> Negative power is parsed correctly</li></ul></td>
<td><code>test_power_negative</code></td>
<td><span class="file-ref">test_serial_parser.c:162</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-003</span></td>
<td>Valid 16-byte node status with state B and no errors</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A 16-byte buffer with state=1 (B), error=0, mode=0 (Normal)</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_node_status is called</li><li class="step-then"><span class="step-keyword">Then</span> All fields parsed correctly</li></ul></td>
<td><code>test_node_status_valid</code></td>
<td><span class="file-ref">test_serial_parser.c:220</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-003</span></td>
<td>Node status with error flags and solar timer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A buffer with RCM_TRIPPED error and large solar timer</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_node_status is called</li><li class="step-then"><span class="step-keyword">Then</span> Error and solar timer are parsed correctly</li></ul></td>
<td><code>test_node_status_error_and_timer</code></td>
<td><span class="file-ref">test_serial_parser.c:248</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-003</span></td>
<td>Node status with mode Smart and max current boundary</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A buffer with mode=1 (Smart) and max current 255 (max byte value)</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_node_status is called</li><li class="step-then"><span class="step-keyword">Then</span> Max current is 255 * 10 = 2550</li></ul></td>
<td><code>test_node_status_max_current_boundary</code></td>
<td><span class="file-ref">test_serial_parser.c:276</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Serial Input Validation (10 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>Irms message with missing fields returns false</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer with only 2 of 4 expected Irms fields</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false</li></ul></td>
<td><code>test_irms_missing_fields</code></td>
<td><span class="file-ref">test_serial_parser.c:91</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>Irms token not found in buffer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer without the Irms token</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false</li></ul></td>
<td><code>test_irms_token_not_found</code></td>
<td><span class="file-ref">test_serial_parser.c:104</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>NULL buffer passed to Irms parser</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A NULL buffer pointer</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false without crashing</li></ul></td>
<td><code>test_irms_null_buffer</code></td>
<td><span class="file-ref">test_serial_parser.c:117</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>Empty buffer passed to Irms parser</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> An empty string buffer</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_irms is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false</li></ul></td>
<td><code>test_irms_empty_buffer</code></td>
<td><span class="file-ref">test_serial_parser.c:130</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>Power message with missing field returns false</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer with only the address, no power value</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_power is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false</li></ul></td>
<td><code>test_power_missing_field</code></td>
<td><span class="file-ref">test_serial_parser.c:177</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>Power token not found in buffer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A serial buffer without the PowerMeasured token</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_power is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false</li></ul></td>
<td><code>test_power_token_not_found</code></td>
<td><span class="file-ref">test_serial_parser.c:190</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>NULL buffer passed to power parser</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A NULL buffer pointer</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_power is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false without crashing</li></ul></td>
<td><code>test_power_null_buffer</code></td>
<td><span class="file-ref">test_serial_parser.c:203</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>Node status buffer too short</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A buffer shorter than 16 bytes</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_node_status is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false</li></ul></td>
<td><code>test_node_status_buffer_too_short</code></td>
<td><span class="file-ref">test_serial_parser.c:297</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>NULL buffer passed to node status parser</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A NULL buffer pointer</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_node_status is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false without crashing</li></ul></td>
<td><code>test_node_status_null_buffer</code></td>
<td><span class="file-ref">test_serial_parser.c:311</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SERIAL-004</span></td>
<td>NULL output passed to node status parser</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A valid buffer but NULL output pointer</li><li class="step-when"><span class="step-keyword">When</span> serial_parse_node_status is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns false without crashing</li></ul></td>
<td><code>test_node_status_null_output</code></td>
<td><span class="file-ref">test_serial_parser.c:324</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Battery Current Calculation (7 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Fresh battery data in solar mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Battery update 30s ago, solar mode, current = 1000</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 1000 (battery current value)</li></ul></td>
<td><code>test_battery_current_fresh_solar_api</code></td>
<td><span class="file-ref">test_serial_parser.c:341</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Stale battery data is ignored after 60 seconds</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Battery update 61s ago</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (stale data ignored)</li></ul></td>
<td><code>test_battery_current_stale_data</code></td>
<td><span class="file-ref">test_serial_parser.c:354</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Battery data exactly at 60 second boundary</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Battery update exactly 60s ago</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns battery current (60s is not stale)</li></ul></td>
<td><code>test_battery_current_boundary_60s</code></td>
<td><span class="file-ref">test_serial_parser.c:367</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Non-solar mode returns zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Normal mode with fresh battery data</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0 (battery only used in solar mode)</li></ul></td>
<td><code>test_battery_current_normal_mode</code></td>
<td><span class="file-ref">test_serial_parser.c:380</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Non-API meter in solar mode still returns battery current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Solar mode with non-API meter type</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns battery current (battery used with any meter in solar mode)</li></ul></td>
<td><code>test_battery_current_non_api_meter</code></td>
<td><span class="file-ref">test_serial_parser.c:393</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Never-updated battery returns zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> time_since_update is 0 (never updated)</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns 0</li></ul></td>
<td><code>test_battery_current_never_updated</code></td>
<td><span class="file-ref">test_serial_parser.c:406</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-001</span></td>
<td>Negative battery current (discharging) in solar mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Battery discharging with negative current value</li><li class="step-when"><span class="step-keyword">When</span> calc_battery_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Returns the negative value</li></ul></td>
<td><code>test_battery_current_negative_discharge</code></td>
<td><span class="file-ref">test_serial_parser.c:419</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Current Sum Calculation (5 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-CALC-002</span></td>
<td>Three-phase system distributes battery current equally</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Three-phase mains at 100,200,300 dA and battery current 300 dA</li><li class="step-when"><span class="step-keyword">When</span> calc_isum is called with enable_c2 = NOT_PRESENT</li><li class="step-then"><span class="step-keyword">Then</span> Battery current divided by 3 (100) subtracted from each phase, Isum = 300</li></ul></td>
<td><code>test_isum_three_phase_battery</code></td>
<td><span class="file-ref">test_serial_parser.c:436</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-003</span></td>
<td>Single-phase battery adjustment uses L1 only</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EnableC2 ALWAYS_OFF, battery current 300 dA</li><li class="step-when"><span class="step-keyword">When</span> calc_isum is called</li><li class="step-then"><span class="step-keyword">Then</span> Full battery current subtracted from L1, L2 and L3 unchanged</li></ul></td>
<td><code>test_isum_single_phase_battery</code></td>
<td><span class="file-ref">test_serial_parser.c:457</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-002</span></td>
<td>Zero battery current leaves mains unchanged</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Zero battery current</li><li class="step-when"><span class="step-keyword">When</span> calc_isum is called</li><li class="step-then"><span class="step-keyword">Then</span> Adjusted currents equal original mains currents</li></ul></td>
<td><code>test_isum_zero_battery</code></td>
<td><span class="file-ref">test_serial_parser.c:478</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-002</span></td>
<td>Negative mains currents (solar injection) with battery</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Negative mains currents and positive battery current</li><li class="step-when"><span class="step-keyword">When</span> calc_isum is called</li><li class="step-then"><span class="step-keyword">Then</span> Battery adjustment makes values more negative</li></ul></td>
<td><code>test_isum_negative_mains</code></td>
<td><span class="file-ref">test_serial_parser.c:499</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-CALC-002</span></td>
<td>Battery current not evenly divisible by 3</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Battery current of 100 (100/3 = 33 per phase, integer division)</li><li class="step-when"><span class="step-keyword">When</span> calc_isum is called</li><li class="step-then"><span class="step-keyword">Then</span> Each phase reduced by 33 (truncated integer division)</li></ul></td>
<td><code>test_isum_battery_rounding</code></td>
<td><span class="file-ref">test_serial_parser.c:520</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">Solar Balancing (20 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-SOLAR-001</span></td>
<td>3-phase solar shortage starts SolarStopTimer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging on 3 phases with EnableC2=AUTO and high mains load</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with large import (Isum=200)</li><li class="step-then"><span class="step-keyword">Then</span> SolarStopTimer is set to a value greater than 0</li></ul></td>
<td><code>test_solar_3p_shortage_starts_timer</code></td>
<td><span class="file-ref">test_solar_balancing.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-002</span></td>
<td>SolarStopTimer reaching 2 or below triggers 3P to 1P phase switch</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging on 3 phases with EnableC2=AUTO and SolarStopTimer=2</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with ongoing shortage</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_1P</li></ul></td>
<td><code>test_solar_3p_timer_triggers_1p_switch</code></td>
<td><span class="file-ref">test_solar_balancing.c:66</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-003</span></td>
<td>1-phase solar surplus near MaxCurrent starts timer for 3P upgrade</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging on 1 phase with IsetBalanced near MaxCurrent and good surplus</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with export (Isum=-100)</li><li class="step-then"><span class="step-keyword">Then</span> SolarStopTimer is set to 63 (countdown to 3P switch)</li></ul></td>
<td><code>test_solar_1p_surplus_starts_timer</code></td>
<td><span class="file-ref">test_solar_balancing.c:88</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-004</span></td>
<td>SolarStopTimer reaching 3 or below on 1P triggers switch to 3P</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging on 1 phase with SolarStopTimer=3 and large surplus</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_solar_1p_timer_triggers_3p_switch</code></td>
<td><span class="file-ref">test_solar_balancing.c:113</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-005</span></td>
<td>Insufficient surplus resets SolarStopTimer to prevent false 3P upgrade</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging on 1 phase with IsetBalanced well below MaxCurrent</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with minimal surplus (Isum=-10)</li><li class="step-then"><span class="step-keyword">Then</span> SolarStopTimer is reset to 0</li></ul></td>
<td><code>test_solar_insufficient_surplus_resets_timer</code></td>
<td><span class="file-ref">test_solar_balancing.c:136</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-006</span></td>
<td>During solar startup period, EVSE is forced to MinCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging with IntTimer below SOLARSTARTTIME (in startup)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[0] is set to MinCurrent*10 regardless of IsetBalanced</li></ul></td>
<td><code>test_solar_startup_forces_mincurrent</code></td>
<td><span class="file-ref">test_solar_balancing.c:159</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-007</span></td>
<td>Past startup period, EVSE uses calculated distribution value</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging with IntTimer past SOLARSTARTTIME</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Balanced[0] uses the calculated value (at least MinCurrent*10)</li></ul></td>
<td><code>test_solar_past_startup_uses_calculated</code></td>
<td><span class="file-ref">test_solar_balancing.c:177</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-008</span></td>
<td>Small solar export results in gradual current increase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging with small export (Isum=-5)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced increases by at least 1 (fine-grained increase)</li></ul></td>
<td><code>test_solar_fine_increase_small</code></td>
<td><span class="file-ref">test_solar_balancing.c:197</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-009</span></td>
<td>Large solar export results in larger current increase</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging with large export (Isum=-50)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced increases by more than the small export case</li></ul></td>
<td><code>test_solar_fine_increase_large</code></td>
<td><span class="file-ref">test_solar_balancing.c:218</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-010</span></td>
<td>Moderate grid import decreases solar charging current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging with IsetBalanced=150 and moderate import (Isum=15)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced decreases below 150</li></ul></td>
<td><code>test_solar_fine_decrease_moderate</code></td>
<td><span class="file-ref">test_solar_balancing.c:239</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-011</span></td>
<td>Large grid import aggressively decreases solar charging current</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is solar charging with IsetBalanced=200 and large import (Isum=50)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced decreases below 200</li></ul></td>
<td><code>test_solar_fine_decrease_aggressive</code></td>
<td><span class="file-ref">test_solar_balancing.c:259</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-012</span></td>
<td>Solar B-state with AUTO and small surplus determines 1-phase charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=AUTO, 3 phases, and small surplus (Isum=-50)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_1P</li></ul></td>
<td><code>test_solar_b_state_auto_determines_1p</code></td>
<td><span class="file-ref">test_solar_balancing.c:279</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-013</span></td>
<td>Solar B-state with AUTO and large surplus determines 3-phase charging</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with EnableC2=AUTO, 1 phase, and large surplus (Isum=-500)</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_solar_b_state_auto_determines_3p</code></td>
<td><span class="file-ref">test_solar_balancing.c:300</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-014</span></td>
<td>Hard current shortage increments NoCurrent counter</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with heavily overloaded mains and low MaxMains</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> NoCurrent counter is incremented above 0</li></ul></td>
<td><code>test_hard_shortage_increments_nocurrent</code></td>
<td><span class="file-ref">test_solar_balancing.c:321</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-015</span></td>
<td>Soft shortage (Isum exceeds MaxSumMains) starts MaxSumMains timer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with Isum exceeding MaxSumMains and MaxSumMainsTime=5</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> MaxSumMainsTimer is set to MaxSumMainsTime*60 (300 seconds)</li></ul></td>
<td><code>test_soft_shortage_starts_maxsummains_timer</code></td>
<td><span class="file-ref">test_solar_balancing.c:342</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-016</span></td>
<td>No shortage condition clears SolarStopTimer and NoCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with low mains load and high MaxMains</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called with no shortage detected</li><li class="step-then"><span class="step-keyword">Then</span> SolarStopTimer and NoCurrent are both reset to 0</li></ul></td>
<td><code>test_no_shortage_clears_timers</code></td>
<td><span class="file-ref">test_solar_balancing.c:367</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-017</span></td>
<td>IsetBalanced is capped at 800 (80A maximum)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with IsetBalanced=900 and large surplus</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced does not exceed 800</li></ul></td>
<td><code>test_isetbalanced_capped_at_800</code></td>
<td><span class="file-ref">test_solar_balancing.c:390</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-018</span></td>
<td>Normal mode forces 3-phase charging regardless of current phase count</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> A standalone EVSE in MODE_NORMAL currently on 1 phase</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_3P</li></ul></td>
<td><code>test_normal_mode_forces_3p</code></td>
<td><span class="file-ref">test_solar_balancing.c:410</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-019</span></td>
<td>phasesLastUpdateFlag=false prevents IsetBalanced regulation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in MODE_SMART with phasesLastUpdateFlag=false and large surplus</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> IsetBalanced remains unchanged (regulation gated)</li></ul></td>
<td><code>test_phases_flag_gates_regulation</code></td>
<td><span class="file-ref">test_solar_balancing.c:437</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-SOLAR-020</span></td>
<td>Multi-EVSE solar startup: EVSE in startup gets MinCurrent, others get calculated</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Two EVSEs as master, EVSE 0 in startup (IntTimer &lt; SOLARSTARTTIME), EVSE 1 past startup</li><li class="step-when"><span class="step-keyword">When</span> evse_calc_balanced_current is called</li><li class="step-then"><span class="step-keyword">Then</span> EVSE 0 Balanced is set to MinCurrent*10 (startup forcing)</li></ul></td>
<td><code>test_multi_evse_solar_startup</code></td>
<td><span class="file-ref">test_solar_balancing.c:460</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">IEC 61851-1 State Transitions (29 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-IEC61851-001</span></td>
<td>EVSE initialises to disconnected state</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is powered on</li><li class="step-when"><span class="step-keyword">When</span> evse_init() is called</li><li class="step-then"><span class="step-keyword">Then</span> The state machine starts in STATE_A (disconnected)</li></ul></td>
<td><code>test_init_state_is_A</code></td>
<td><span class="file-ref">test_state_transitions.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-002</span></td>
<td>Contactors are open after initialisation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is powered on</li><li class="step-when"><span class="step-keyword">When</span> evse_init() is called</li><li class="step-then"><span class="step-keyword">Then</span> Both contactor1 and contactor2 are off (open)</li></ul></td>
<td><code>test_init_contactors_off</code></td>
<td><span class="file-ref">test_state_transitions.c:45</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-003</span></td>
<td>Pilot signal is connected after initialisation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is powered on</li><li class="step-when"><span class="step-keyword">When</span> evse_init() is called</li><li class="step-then"><span class="step-keyword">Then</span> The pilot signal is connected (pilot_connected is true)</li></ul></td>
<td><code>test_init_pilot_connected</code></td>
<td><span class="file-ref">test_state_transitions.c:59</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-004</span></td>
<td>No error flags after initialisation</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is powered on</li><li class="step-when"><span class="step-keyword">When</span> evse_init() is called</li><li class="step-then"><span class="step-keyword">Then</span> ErrorFlags is NO_ERROR</li></ul></td>
<td><code>test_init_no_errors</code></td>
<td><span class="file-ref">test_state_transitions.c:72</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-005</span></td>
<td>STATE_A remains when no vehicle is connected</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A (disconnected) and ready to charge</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (no vehicle present)</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_A</li></ul></td>
<td><code>test_A_stays_A_on_12V</code></td>
<td><span class="file-ref">test_state_transitions.c:85</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-006</span></td>
<td>Vehicle connection triggers STATE_A to STATE_B transition</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A, authorized, and ready to charge</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B (connected, not charging)</li></ul></td>
<td><code>test_A_to_B_on_9V_when_ready</code></td>
<td><span class="file-ref">test_state_transitions.c:99</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-007</span></td>
<td>Modem negotiation required before STATE_B when ModemStage is 0</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with ModemStage=0 (unauthenticated modem)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_MODEM_REQUEST for ISO15118 negotiation</li></ul></td>
<td><code>test_A_to_modem_when_modem_stage_0</code></td>
<td><span class="file-ref">test_state_transitions.c:113</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-007B</span></td>
<td>A→B goes directly to STATE_B when modem is disabled</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with ModemStage=0 but ModemEnabled=false</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions directly to STATE_B (modem flow skipped)</li></ul></td>
<td><code>test_A_to_B_skips_modem_when_disabled</code></td>
<td><span class="file-ref">test_state_transitions.c:132</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-008</span></td>
<td>Unauthorized EVSE blocks STATE_A to STATE_B transition</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with AccessStatus OFF (not authorized)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-then"><span class="step-keyword">Then</span> The state remains STATE_A (transition blocked)</li></ul></td>
<td><code>test_A_stays_A_when_access_off</code></td>
<td><span class="file-ref">test_state_transitions.c:151</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-011</span></td>
<td>Vehicle disconnect in STATE_B returns to STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with an active TEMP_HIGH error flag</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with ChargeDelay &gt; 0</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B (vehicle connected, not charging)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (vehicle disconnected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (connected, waiting due to error)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (connected, waiting for delay)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions back to STATE_A (disconnected)</li></ul></td>
<td><code>test_B_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_state_transitions.c:166</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-012</span></td>
<td>Vehicle charge request after diode check triggers STATE_B to STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with DiodeCheck passed and sufficient current</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal is sustained for 500ms (vehicle requests charge)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_C (charging)</li></ul></td>
<td><code>test_B_to_C_on_6V_with_diode_check</code></td>
<td><span class="file-ref">test_state_transitions.c:213</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-013</span></td>
<td>Charge request without diode check does not transition to STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with DiodeCheck NOT passed</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal is sustained for 500ms</li><li class="step-then"><span class="step-keyword">Then</span> The state does NOT transition to STATE_C</li></ul></td>
<td><code>test_B_to_C_requires_diode_check</code></td>
<td><span class="file-ref">test_state_transitions.c:234</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-014</span></td>
<td>PILOT_DIODE signal sets DiodeCheck flag</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with DiodeCheck=0</li><li class="step-when"><span class="step-keyword">When</span> A PILOT_DIODE signal is received</li><li class="step-then"><span class="step-keyword">Then</span> DiodeCheck is set to 1</li></ul></td>
<td><code>test_diode_check_sets_on_pilot_diode</code></td>
<td><span class="file-ref">test_state_transitions.c:255</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-015</span></td>
<td>Contactor 1 is closed when entering STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE transitions to STATE_C (charging)</li><li class="step-when"><span class="step-keyword">When</span> evse_set_state is called with STATE_C</li><li class="step-then"><span class="step-keyword">Then</span> contactor1_state is true (closed, power flowing)</li></ul></td>
<td><code>test_C_contactor1_on</code></td>
<td><span class="file-ref">test_state_transitions.c:271</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-016</span></td>
<td>Vehicle disconnect during charging returns to STATE_A with contactors open</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging)</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (vehicle disconnected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_A and contactor1 is opened</li></ul></td>
<td><code>test_C_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_state_transitions.c:285</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-019</span></td>
<td>Vehicle disconnect from STATE_C1 returns to STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging)</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging)</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C1 (charging suspended)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle stops charge request)</li><li class="step-when"><span class="step-keyword">When</span> PILOT_SHORT is sustained for more than 500ms (debounce period)</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (vehicle disconnected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B and DiodeCheck is reset to 0</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_A</li></ul></td>
<td><code>test_C1_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_state_transitions.c:301</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-022</span></td>
<td>Vehicle disconnect from STATE_B1 returns to STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C1 (charging suspended)</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C1 with C1Timer set to 6 seconds</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B1 (waiting) with pilot reconnected</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received</li><li class="step-when"><span class="step-keyword">When</span> The C1Timer counts down to zero via tick_1s</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (vehicle disconnected)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 (waiting), not STATE_B</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B1 and both contactors are opened</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_A</li></ul></td>
<td><code>test_B1_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_state_transitions.c:352</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-023</span></td>
<td>Entering STATE_B1 sets a non-zero ChargeDelay</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is ready to charge with ChargeDelay=0</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_B1</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay is set to a value greater than 0</li></ul></td>
<td><code>test_set_state_B1_sets_charge_delay</code></td>
<td><span class="file-ref">test_state_transitions.c:410</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-024</span></td>
<td>Entering STATE_A clears LESS_6A error and ChargeDelay</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has LESS_6A error flag set and ChargeDelay &gt; 0</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_A</li><li class="step-then"><span class="step-keyword">Then</span> LESS_6A is cleared from ErrorFlags and ChargeDelay is set to 0</li></ul></td>
<td><code>test_set_state_A_clears_errors_and_delay</code></td>
<td><span class="file-ref">test_state_transitions.c:425</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-025</span></td>
<td>State transitions are recorded in the transition log</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is ready to charge</li><li class="step-when"><span class="step-keyword">When</span> Two state transitions occur (STATE_B then STATE_C)</li><li class="step-then"><span class="step-keyword">Then</span> transition_count is 2 and the log contains both states in order</li></ul></td>
<td><code>test_transition_log_records_states</code></td>
<td><span class="file-ref">test_state_transitions.c:442</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-026</span></td>
<td>Entering STATE_C1 sets PWM to off (+12V)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_C (charging)</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_C1 (charging suspended)</li><li class="step-then"><span class="step-keyword">Then</span> PWM duty is set to 1024 (off / +12V constant)</li></ul></td>
<td><code>test_set_state_C1_sets_pwm_off</code></td>
<td><span class="file-ref">test_state_transitions.c:459</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-027</span></td>
<td>Full charge cycle: A -&gt; B -&gt; C -&gt; B -&gt; A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A, authorized and ready to charge</li><li class="step-when"><span class="step-keyword">When</span> The vehicle connects (9V), requests charge (6V), stops (9V), disconnects (12V)</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions A-&gt;B-&gt;C-&gt;B-&gt;A with correct contactor states</li></ul></td>
<td><code>test_full_charge_cycle</code></td>
<td><span class="file-ref">test_state_transitions.c:474</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-028</span></td>
<td>Vehicle disconnect during ACTSTART is NOT handled in tick_10ms</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_ACTSTART (activation mode)</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal is received (vehicle disconnected)</li><li class="step-then"><span class="step-keyword">Then</span> The state stays ACTSTART (original behavior: no pilot check in ACTSTART,</li></ul></td>
<td><code>test_actstart_to_A_on_disconnect</code></td>
<td><span class="file-ref">test_state_transitions.c:511</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-029</span></td>
<td>ActivationMode=0 triggers STATE_ACTSTART on pilot detection in STATE_B</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_B with ActivationMode=0</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_ACTSTART with ActivationTimer set to 3</li></ul></td>
<td><code>test_activation_mode_triggers_actstart</code></td>
<td><span class="file-ref">test_state_transitions.c:528</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-031</span></td>
<td>ActivationMode=255 (always active) does not count down</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE has ActivationMode set to 5</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE has ActivationMode set to 255</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-when"><span class="step-keyword">When</span> One second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> ActivationMode decrements to 4</li><li class="step-then"><span class="step-keyword">Then</span> ActivationMode remains at 255</li></ul></td>
<td><code>test_activation_mode_255_does_not_countdown</code></td>
<td><span class="file-ref">test_state_transitions.c:545</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-032</span></td>
<td>STATE_ACTSTART returns to STATE_B when ActivationTimer expires</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_ACTSTART with ActivationTimer=0 (expired)</li><li class="step-when"><span class="step-keyword">When</span> A non-12V pilot signal is received</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B and ActivationMode is set to 255</li></ul></td>
<td><code>test_actstart_returns_to_B_when_timer_expires</code></td>
<td><span class="file-ref">test_state_transitions.c:576</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-PHASE-002</span></td>
<td>STATE_B re-entry sets Switching_Phases_C2 flag instead of direct phase change</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_COMM_B_OK (master approved B transition)</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_COMM_C_OK (master approved C transition)</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is configured as a node (LoadBl=2)</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is in STATE_A with EnableC2=ALWAYS_OFF and 3 phases configured</li><li class="step-given"><span class="step-keyword">Given</span> The EVSE is already in STATE_B with EnableC2=ALWAYS_OFF and 3 phases configured</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal is received</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received (vehicle connected)</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_B</li><li class="step-when"><span class="step-keyword">When</span> The state is set to STATE_B again</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_B and ActivationMode is set to 30</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_C (charging)</li><li class="step-then"><span class="step-keyword">Then</span> The state transitions to STATE_COMM_B (requesting master permission)</li><li class="step-then"><span class="step-keyword">Then</span> Nr_Of_Phases_Charging is set directly to 1 (single phase)</li><li class="step-then"><span class="step-keyword">Then</span> Switching_Phases_C2 is set to GOING_TO_SWITCH_1P (deferred switch)</li></ul></td>
<td><code>test_state_B_calls_check_switching_phases_from_B</code></td>
<td><span class="file-ref">test_state_transitions.c:593</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-M3</span></td>
<td>STATE_B entry does NOT set pilot_connected when modem disabled</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=false, EVSE transitions A→B</li><li class="step-when"><span class="step-keyword">When</span> evse_set_state is called with STATE_B</li><li class="step-then"><span class="step-keyword">Then</span> pilot_connected is NOT explicitly set by STATE_B entry</li></ul></td>
<td><code>test_state_b_no_pilot_reconnect_without_modem</code></td>
<td><span class="file-ref">test_state_transitions.c:688</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-IEC61851-M3B</span></td>
<td>STATE_B entry DOES set pilot_connected when modem enabled</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> ModemEnabled=true, EVSE transitions to STATE_B</li><li class="step-when"><span class="step-keyword">When</span> evse_set_state is called with STATE_B</li><li class="step-then"><span class="step-keyword">Then</span> pilot_connected is set to true</li></ul></td>
<td><code>test_state_b_pilot_reconnect_with_modem</code></td>
<td><span class="file-ref">test_state_transitions.c:710</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">10ms Tick Processing (20 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-TICK10-001</span></td>
<td>Pilot disconnect guard ignores 9V signal while active</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge with PilotDisconnected=true and PilotDisconnectTime &gt; 0</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal (vehicle connected) is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE remains in STATE_A because the disconnect guard suppresses the pilot reading</li></ul></td>
<td><code>test_pilot_disconnect_guards_reading</code></td>
<td><span class="file-ref">test_tick_10ms.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-002</span></td>
<td>Pilot disconnect flag clears when timer reaches zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge with PilotDisconnected=true and PilotDisconnectTime=0</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> PilotDisconnected is cleared to false and pilot_connected is set to true</li></ul></td>
<td><code>test_pilot_disconnect_clears_on_timer_zero</code></td>
<td><span class="file-ref">test_tick_10ms.c:47</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-003</span></td>
<td>RFID reader type 1 starts access lock timer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge with RFIDReader=1, AccessTimer=0, and AccessStatus=ON</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal (no vehicle) is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> AccessTimer is set to RFIDLOCKTIME to begin the RFID lock countdown</li></ul></td>
<td><code>test_rfid_reader_1_starts_access_timer</code></td>
<td><span class="file-ref">test_tick_10ms.c:66</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-004</span></td>
<td>MaxCapacity limits charge current when below MaxCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge with MaxCapacity=8A which is less than MaxCurrent=13A</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal triggers the A-to-B transition during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 80 deciamps (MaxCapacity * 10)</li></ul></td>
<td><code>test_maxcapacity_limits_charge_current</code></td>
<td><span class="file-ref">test_tick_10ms.c:85</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-005</span></td>
<td>MaxCapacity at or above MaxCurrent falls back to MinCurrent</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge with MaxCapacity=16A &gt;= MaxCurrent=13A and MinCurrent=6A</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal triggers the A-to-B transition during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> ChargeCurrent is set to 60 deciamps (MinCurrent * 10) as the default starting point</li></ul></td>
<td><code>test_maxcapacity_default_uses_mincurrent</code></td>
<td><span class="file-ref">test_tick_10ms.c:101</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-006</span></td>
<td>LESS_6A error flag set when insufficient current available in Smart mode</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode standalone with very low MaxMains=2A and MainsMeterImeasured=200 (overloaded)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal (vehicle connected) is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The LESS_6A error flag is set because available current is below MinCurrent</li></ul></td>
<td><code>test_less_6a_when_no_current_available</code></td>
<td><span class="file-ref">test_tick_10ms.c:120</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-007</span></td>
<td>STATE_B with 6V pilot increments state timer for debounce</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_B with DiodeCheck=1 and StateTimer=0</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal (vehicle requesting charge) is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> StateTimer increments to 1, counting toward the B-to-C debounce threshold</li></ul></td>
<td><code>test_b_6v_increments_state_timer</code></td>
<td><span class="file-ref">test_tick_10ms.c:144</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-008</span></td>
<td>STATE_B with 9V pilot resets the state timer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_B with StateTimer=30 (partially debounced)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal (vehicle connected but not requesting charge) is received</li><li class="step-then"><span class="step-keyword">Then</span> StateTimer is reset to 0, canceling the B-to-C debounce countdown</li></ul></td>
<td><code>test_b_9v_resets_state_timer</code></td>
<td><span class="file-ref">test_tick_10ms.c:161</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-009</span></td>
<td>STATE_B to STATE_C transition requires 55 consecutive 6V ticks</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_B with DiodeCheck=1 and ChargeCurrent at MaxCurrent</li><li class="step-when"><span class="step-keyword">When</span> 50 consecutive 6V pilot ticks are received (below threshold) then 5 more (reaching 55)</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE does not transition at 50 ticks but transitions to STATE_C at 55 ticks</li></ul></td>
<td><code>test_b_to_c_debounce_threshold</code></td>
<td><span class="file-ref">test_tick_10ms.c:178</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-010</span></td>
<td>STATE_B to STATE_C transition is blocked when errors are present</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_B with DiodeCheck=1 but ErrorFlags contains TEMP_HIGH</li><li class="step-when"><span class="step-keyword">When</span> 55 consecutive 6V pilot ticks are received (past debounce threshold)</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE does not transition to STATE_C because an error condition is active</li></ul></td>
<td><code>test_b_to_c_requires_diode_and_no_errors</code></td>
<td><span class="file-ref">test_tick_10ms.c:201</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-011</span></td>
<td>STATE_C transitions to STATE_B after sustained pilot short debounce</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_C (actively charging)</li><li class="step-when"><span class="step-keyword">When</span> Fewer than 50 PILOT_SHORT ticks are received followed by enough to exceed 50 total</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE stays in STATE_C below 50 ticks but transitions to STATE_B after 50 consecutive short ticks</li></ul></td>
<td><code>test_c_short_debounce</code></td>
<td><span class="file-ref">test_tick_10ms.c:222</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-012</span></td>
<td>STATE_C stays in STATE_C on 6V pilot and resets state timer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_C with StateTimer=20</li><li class="step-when"><span class="step-keyword">When</span> A 6V pilot signal is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE remains in STATE_C and StateTimer is reset to 0</li></ul></td>
<td><code>test_c_6v_no_transition</code></td>
<td><span class="file-ref">test_tick_10ms.c:243</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-013</span></td>
<td>COMM_B state does not trigger A-to-B transition logic on 9V pilot</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a node (LoadBl=2) in STATE_COMM_B waiting for master confirmation</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE does not transition to STATE_B because COMM_B bypasses the A-to-B path</li></ul></td>
<td><code>test_comm_b_stays_on_9v</code></td>
<td><span class="file-ref">test_tick_10ms.c:262</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-014</span></td>
<td>Node transitions from STATE_B to STATE_COMM_C instead of STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a node (LoadBl=2) in STATE_B with DiodeCheck=1 and sufficient charge current</li><li class="step-when"><span class="step-keyword">When</span> 55 consecutive 6V pilot ticks are received (past debounce threshold)</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_COMM_C (waiting for master to confirm charge start)</li></ul></td>
<td><code>test_node_b_to_comm_c</code></td>
<td><span class="file-ref">test_tick_10ms.c:286</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-015</span></td>
<td>A-to-B transition sets BalancedMax from MaxCapacity</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge in standalone mode with MaxCapacity=10A</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal triggers the A-to-B transition</li><li class="step-then"><span class="step-keyword">Then</span> BalancedMax[0] is set to 100 deciamps (MaxCapacity * 10)</li></ul></td>
<td><code>test_a_to_b_sets_balanced_max</code></td>
<td><span class="file-ref">test_tick_10ms.c:309</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-016</span></td>
<td>A-to-B transition does NOT set extra PWM duty (F3 fidelity fix)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge in standalone mode</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal triggers the A-to-B transition</li><li class="step-then"><span class="step-keyword">Then</span> PWM duty remains 1024 (from STATE_A entry); module does not set PWM on A→B,</li></ul></td>
<td><code>test_a_to_b_no_extra_pwm</code></td>
<td><span class="file-ref">test_tick_10ms.c:324</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-017</span></td>
<td>A-to-B transition initializes ActivationMode to 30 and clears AccessTimer</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is ready to charge in standalone mode</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal triggers the A-to-B transition</li><li class="step-then"><span class="step-keyword">Then</span> ActivationMode is set to 30 (countdown for activation) and AccessTimer is cleared to 0</li></ul></td>
<td><code>test_a_to_b_sets_activation_mode_30</code></td>
<td><span class="file-ref">test_tick_10ms.c:343</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-018</span></td>
<td>STATE_B1 remains in B1 when errors are present on 9V pilot</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_B1 (connected but waiting) with TEMP_HIGH error flag set</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE stays in STATE_B1 because errors prevent transition to charging states</li></ul></td>
<td><code>test_b1_with_errors_stays_b1_on_9v</code></td>
<td><span class="file-ref">test_tick_10ms.c:360</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-019</span></td>
<td>Modem states are NOT handled in tick_10ms (matches original Timer10ms)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in one of the modem states (REQUEST, WAIT, DONE, or DENIED)</li><li class="step-when"><span class="step-keyword">When</span> A 12V pilot signal (no vehicle) is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE stays in its modem state (modem is managed solely by tick_1s)</li></ul></td>
<td><code>test_modem_states_to_a_on_12v</code></td>
<td><span class="file-ref">test_tick_10ms.c:381</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK10-020</span></td>
<td>ACTSTART transitions to STATE_B when activation timer expires</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_ACTSTART with ActivationTimer=0 (timer expired)</li><li class="step-when"><span class="step-keyword">When</span> A 9V pilot signal is received during a 10ms tick</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_B and ActivationMode is set to 255 (disabled)</li></ul></td>
<td><code>test_actstart_to_b_when_timer_zero</code></td>
<td><span class="file-ref">test_tick_10ms.c:403</span></td>
</tr>
</tbody></table>
</div>
<div class="feature-section">
<div class="feature-title">1-Second Tick Processing (20 scenarios)</div>
<div class="coverage-bar">
<div class="coverage-fill" style="width:100.0%"></div>
</div>
<table>
<thead><tr>
<th>Requirement</th><th>Scenario</th><th>Steps</th><th>Test Function</th><th>Source</th>
</tr></thead>
<tbody>
<tr>
<td><span class="req-tag">REQ-TICK1S-001</span></td>
<td>SolarStopTimer decrements by one each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in normal mode with SolarStopTimer=3</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> SolarStopTimer decrements to 2</li></ul></td>
<td><code>test_solar_stop_timer_countdown</code></td>
<td><span class="file-ref">test_tick_1s.c:1</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-002</span></td>
<td>SolarStopTimer expiry triggers STATE_C to STATE_C1 transition</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_C with high mains load and SolarStopTimer=1</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick decrements SolarStopTimer to 0</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_C1 (charging suspended) and LESS_6A error flag is set</li></ul></td>
<td><code>test_solar_stop_timer_triggers_c1</code></td>
<td><span class="file-ref">test_tick_1s.c:39</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-003</span></td>
<td>SolarStopTimer expiry does not trigger C1 when not in STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_B (not charging) with SolarStopTimer=1</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick decrements SolarStopTimer to 0</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE does not transition to STATE_C1 but LESS_6A error flag is still set</li></ul></td>
<td><code>test_solar_stop_timer_not_in_c</code></td>
<td><span class="file-ref">test_tick_1s.c:62</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-004</span></td>
<td>Node charge timers increment when node is in STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Node 0 is in STATE_C with IntTimer=5 and Timer=100</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> IntTimer increments to 6 and Timer increments to 101</li></ul></td>
<td><code>test_node_charge_timer_increments</code></td>
<td><span class="file-ref">test_tick_1s.c:86</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-005</span></td>
<td>Node charge timer resets when node is not in STATE_C</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Node 0 is in STATE_B (connected but not charging) with IntTimer=20</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> IntTimer is reset to 0</li></ul></td>
<td><code>test_node_charge_timer_resets</code></td>
<td><span class="file-ref">test_tick_1s.c:104</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-006</span></td>
<td>Multiple node charge timers update independently based on each node state</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> Nodes 0 and 2 are in STATE_C (charging) and node 1 is in STATE_B, all with IntTimer=10</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> Nodes 0 and 2 increment to 11 while node 1 resets to 0</li></ul></td>
<td><code>test_multi_node_timers</code></td>
<td><span class="file-ref">test_tick_1s.c:120</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-007</span></td>
<td>MainsMeter timeout sets CT_NOCOMM error on node</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a node (LoadBl=2) with MainsMeterTimeout=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> CT_NOCOMM error flag is set indicating mains meter communication lost</li></ul></td>
<td><code>test_mains_meter_timeout_node</code></td>
<td><span class="file-ref">test_tick_1s.c:144</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-008</span></td>
<td>MainsMeter timeout counter decrements on node each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is a node (LoadBl=3) with MainsMeterTimeout=5</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> MainsMeterTimeout decrements to 4</li></ul></td>
<td><code>test_mains_meter_node_countdown</code></td>
<td><span class="file-ref">test_tick_1s.c:161</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-009</span></td>
<td>LESS_6A error forces STATE_C to STATE_C1 via power unavailable</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_C with LESS_6A error flag set and high mains load</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_C1 (charging suspended due to insufficient power)</li></ul></td>
<td><code>test_less_6a_enforces_power_unavailable</code></td>
<td><span class="file-ref">test_tick_1s.c:179</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-010</span></td>
<td>LESS_6A error sets ChargeDelay to CHARGEDELAY (60 seconds)</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_B1 with LESS_6A error flag set and ChargeDelay=0</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay is set to CHARGEDELAY (60 seconds) to prevent rapid retry</li></ul></td>
<td><code>test_less_6a_sets_charge_delay</code></td>
<td><span class="file-ref">test_tick_1s.c:201</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-011</span></td>
<td>MaxSumMains timer decrements each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has MaxSumMainsTimer=5</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> MaxSumMainsTimer decrements to 4</li></ul></td>
<td><code>test_maxsummains_timer_countdown</code></td>
<td><span class="file-ref">test_tick_1s.c:226</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-012</span></td>
<td>MaxSumMains timer expiry triggers STATE_C to STATE_C1 transition</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_C with high mains load and MaxSumMainsTimer=1</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick decrements MaxSumMainsTimer to 0</li><li class="step-then"><span class="step-keyword">Then</span> The EVSE transitions to STATE_C1 and LESS_6A error flag is set</li></ul></td>
<td><code>test_maxsummains_timer_triggers_c1</code></td>
<td><span class="file-ref">test_tick_1s.c:241</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-013</span></td>
<td>AccessTimer is cleared when EVSE is not in STATE_A</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in STATE_B with AccessTimer=30</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> AccessTimer is cleared to 0 because it is only relevant in STATE_A</li></ul></td>
<td><code>test_access_timer_cleared_not_in_a</code></td>
<td><span class="file-ref">test_tick_1s.c:265</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-014</span></td>
<td>EV meter timeout counter decrements each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVMeterType=1 (meter installed) with EVMeterTimeout=5</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EVMeterTimeout decrements to 4</li></ul></td>
<td><code>test_ev_meter_timeout_countdown</code></td>
<td><span class="file-ref">test_tick_1s.c:283</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-015</span></td>
<td>EV meter timeout reaching zero sets EV_NOCOMM error</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVMeterType=1 with EVMeterTimeout=0 and no existing errors in Smart mode</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> EV_NOCOMM error flag is set indicating EV meter communication lost</li></ul></td>
<td><code>test_ev_meter_timeout_triggers_error</code></td>
<td><span class="file-ref">test_tick_1s.c:299</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-016</span></td>
<td>Activation timer decrements each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has ActivationTimer=3</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> ActivationTimer decrements to 2</li></ul></td>
<td><code>test_activation_timer_countdown</code></td>
<td><span class="file-ref">test_tick_1s.c:319</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-017</span></td>
<td>ActivationMode counter decrements each second</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE has ActivationMode=10</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> ActivationMode decrements to 9</li></ul></td>
<td><code>test_activation_mode_countdown</code></td>
<td><span class="file-ref">test_tick_1s.c:336</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-018</span></td>
<td>ChargeDelay is overridden by LESS_6A enforcement after decrementing to zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_B1 with ChargeDelay=1 and LESS_6A error flag set</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick decrements ChargeDelay to 0 then LESS_6A enforcement re-sets it</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay is set back to CHARGEDELAY (60 seconds) by LESS_6A enforcement</li></ul></td>
<td><code>test_charge_delay_overridden_by_less_6a</code></td>
<td><span class="file-ref">test_tick_1s.c:353</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-F2A</span></td>
<td>LESS_6A resets ChargeDelay to CHARGEDELAY every tick, even when non-zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_B1 with LESS_6A set and ChargeDelay=30</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay is reset to CHARGEDELAY (60), not decremented to 29</li></ul></td>
<td><code>test_less_6a_resets_charge_delay_every_tick</code></td>
<td><span class="file-ref">test_tick_1s.c:378</span></td>
</tr>
<tr>
<td><span class="req-tag">REQ-TICK1S-F2B</span></td>
<td>LESS_6A prevents ChargeDelay from ever reaching zero</td>
<td><ul class="scenario-steps"><li class="step-given"><span class="step-keyword">Given</span> EVSE is in Smart mode in STATE_B1 with LESS_6A set and ChargeDelay=1</li><li class="step-when"><span class="step-keyword">When</span> A 1-second tick occurs (ChargeDelay decrements to 0, then LESS_6A resets it)</li><li class="step-then"><span class="step-keyword">Then</span> ChargeDelay is CHARGEDELAY (60), not 0</li></ul></td>
<td><code>test_less_6a_charge_delay_never_reaches_zero</code></td>
<td><span class="file-ref">test_tick_1s.c:400</span></td>
</tr>
</tbody></table>
</div>
<footer>Generated by extract_traceability.py | SmartEVSE-3 Specification by Example</footer>
</body></html>